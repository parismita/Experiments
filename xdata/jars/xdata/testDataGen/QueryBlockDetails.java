package testDataGen;

import generateConstraints.ConstraintGenerator;
import generateConstraints.Constraints;
import generateConstraints.GenerateConstraintsForCaseConditions;
import generateConstraints.GenerateConstraintsForConjunct;
import generateConstraints.GenerateConstraintsForHavingClause;
import generateConstraints.GenerateConstraintsForWhereClauseSubQueryBlock;
import generateConstraints.GenerateGroupByConstraints;
import generateConstraints.GenerateJoinPredicateConstraints;
import generateConstraints.GenerateUniqueKeyConstraints;

import java.io.Serializable;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.healthmarketscience.sqlbuilder.dbspec.Join;
import com.microsoft.z3.ArithExpr;
import com.microsoft.z3.ArrayExpr;
import com.microsoft.z3.BoolExpr;
import com.microsoft.z3.Context;
import com.microsoft.z3.Expr;
import com.microsoft.z3.Sort;

import GenConstraints.GenConstraints;
import parsing.AggregateFunction;
import parsing.CaseCondition;
import parsing.Column;
//import parsing.Conjunct;
import parsing.CaseExpression;
import parsing.ConjunctQueryStructure;
import parsing.FromClauseElement;
import parsing.MutationStructure;
import parsing.Node;
import parsing.QueryParser;
import parsing.QueryStructure;
import parsing.RelationHierarchyNode;
import parsing.Table;
import parsing.correlationStructure;
import stringSolver.StringConstraintSolver;
import util.ConstraintObject;
import util.TableMap;
import generateConstraints.UtilsRelatedToNode; // added by sunanda
import util.Configuration; // added to this file by sunanda for subquery approach

/**
 * This class stores details of a query block
 * If the given query contains nested subqueries
 * then we have to create a new query block for each nested subquery block and
 * for the outer query block
 * 
 * @author mahesh
 *
 */
public class QueryBlockDetails implements Serializable {

	private static final long serialVersionUID = 6036368868346030666L;
	private static Logger logger = Logger.getLogger(QueryBlockDetails.class.getName());

	public ArrayList<String> getNonEmptyConstraints() {
		return NonEmptyConstraints;
	}

	public void setNonEmptyConstraints(ArrayList<String> nonEmptyConstraints) {
		NonEmptyConstraints = nonEmptyConstraints;
	}

	/** The list of the columns that are projected out in this query block */
	private ArrayList<Node> projectedCols;

	/**
	 * The list of the aggregation functions that are projected out in this query
	 * block
	 */
	private ArrayList<AggregateFunction> aggFunc;

	/** Stores details about the where clause of this query block */
	private ArrayList<ConjunctQueryStructure> conjuncts;

	/**
	 * Stores details about the where clause of this query block from query
	 * structure
	 */
	private ArrayList<ConjunctQueryStructure> conjunctsqs;

	/** The group by nodes of this query block */
	private ArrayList<Node> groupByNodes;
	private ArrayList<Node> orderByNodes;

	/** The having clause of this query block, if any */
	private Node havingClause;

	/**
	 * The havingClause is flattenned into this vector
	 * FIXME: We are handling only ANDing of conditions in havingClause but not
	 * ORing of the conditions
	 */
	private ArrayList<Node> aggConstraints;

	/**
	 * The number of tuples needed to satisfy the constrained aggregation in this
	 * query block
	 */
	private int finalCount;
	public int setNo;

	/*** The number of groups of tuples to be generated by this query block */
	private int noOfGroups;

	private ArrayList<String> NonEmptyConstraints;
	/** Stores details about each from clause subquery block */
	private ArrayList<QueryBlockDetails> fromClauseSubQueries;

	/** Stores details about each where clause subquery block */
	private ArrayList<QueryBlockDetails> whereClauseSubQueries;

	/** Stores the Case conditions if the query contains CASE statements */
	private Map<Integer, CaseExpression> caseConditionMap;

	/**
	 * Used to store the attributes(can be a single attribute or multiple
	 * attributes) which must contain distinct values across multiples tuples of the
	 * relation
	 * Examples include the attributes which form unique/primary key
	 */
	Set<HashSet<Node>> uniqueElements;

	/**
	 * Used to store the attributes which must contain same value across multiples
	 * tuples of the group
	 * Examples include group by attributes
	 */
	private Set<Node> singleValuedAttributes;

	/**
	 * To kill some mutations we might require some of the attributes to be
	 * distinct. These are stored here
	 */
	private Set<HashSet<Node>> uniqueElementsAdd;

	/**
	 * To kill some mutations we might require some of the attributes to be single
	 * valued. These are stored here
	 */

	private Set<Node> singleValuedAttributesAdd;

	/** Stores the equivalence class that is being killed */
	private Vector<Vector<Node>> equivalenceClassesKilled;

	/** Stores the names of base relations (Can be repeated) in this query block */
	ArrayList<String> baseRelations;
	ArrayList<String> baseSQRelations;
	/**
	 * The variables uniqueElements, singleValuedAttributes,
	 * singleValuedAttributesAdd, uniqueElementsAdd and equivalenceClassesKilled
	 * are used by tuple assignment method
	 */

	/**
	 * Indicates whether this query block contains constrained aggregation or not
	 */
	private boolean isConstrainedAggregation;

	/** Indicates whether this query block contains distinct or not */
	private boolean isDistinct;

	/**
	 * for each relation occurrence, stores the count needed to satisfy the
	 * constrained aggregation function on that relation
	 */
	private HashMap<String, Integer> finalCountMap;

	/** Stores the list of aggregate functions over a column of the relation */
	private HashMap<Column, ArrayList<Node>> colAggMap;

	/** Related to general parameters in the input query */
	private HashMap<String, String> paramMap;

	private HashMap<ArrayList<String>, Node> paramsNodeMap;

	private int pConstraintId;

	private int paramCount;

	private HashMap<String, Node> constraintsWithParameters;

	private RelationHierarchyNode topLevelRelation;
	private int level;
	private int limit;

	/**
	 * The constructor for this method
	 */
	public QueryBlockDetails() {
		setNo=0;

		projectedCols = new ArrayList<Node>();
		aggFunc = new ArrayList<AggregateFunction>();
		conjuncts = new ArrayList<ConjunctQueryStructure>();
		groupByNodes = new ArrayList<Node>();
		isConstrainedAggregation = false;
		isDistinct = false;
		havingClause = null;
		aggConstraints = new ArrayList<Node>();
		finalCount = 0;
		noOfGroups = 1;
		uniqueElements = new HashSet<HashSet<Node>>();
		uniqueElementsAdd = new HashSet<HashSet<Node>>();
		singleValuedAttributes = new HashSet<Node>();
		singleValuedAttributesAdd = new HashSet<Node>();
		equivalenceClassesKilled = new Vector<Vector<Node>>();
		fromClauseSubQueries = new ArrayList<QueryBlockDetails>();
		whereClauseSubQueries = new ArrayList<QueryBlockDetails>();
		baseRelations = new ArrayList<String>();
		baseSQRelations = new ArrayList<String>();
		finalCountMap = new HashMap<String, Integer>();
		paramMap = new HashMap<String, String>();
		paramsNodeMap = new HashMap<ArrayList<String>, Node>();
		paramCount = 0;
		pConstraintId = 0;
		constraintsWithParameters = new HashMap<String, Node>();
		level = 0;
		limit = 0;
		// setCaseConditionMap(new HashMap<Integer,Vector<CaseCondition>>());
	}

	/**
	 * This function initialize the query block details
	 * 
	 * @param qp
	 */
	/*
	 * public static QueryBlockDetails intializeQueryBlockDetails(QueryParser qp){
	 * 
	 * QueryBlockDetails qbt = new QueryBlockDetails();
	 * 
	 * qbt.setProjectedCols( new ArrayList<Node>(qp.getProjectedCols()) );
	 * qbt.setAggFunc( new ArrayList<AggregateFunction>(qp.getAggFunc()) );
	 * //qbt.setConjuncts( new ArrayList<Conjunct>(qp.getConjuncts()) );
	 * qbt.setGroupByNodes( new ArrayList<Node>(qp.getGroupByNodes()) );
	 * qbt.setCaseConditionMap(new HashMap<Integer,Vector<CaseCondition>>
	 * (qp.getCaseConditionMap()) );
	 * qbt.setCaseConditionMap(new HashMap<Integer,Vector<CaseCondition>>
	 * (qp.getCaseConditionMap()) );
	 * 
	 * qbt.setHavingClause(qp.getHavingClause());
	 * if(qbt.getHavingClause() != null)
	 * qbt.setConstrainedAggregation(true);
	 * 
	 * qbt.setTopLevelRelation(qp.topLevelRelation);
	 * 
	 * return qbt;
	 * }
	 */

	/**
	 * This function initialize the query block details
	 * 
	 * @param qp
	 */
	public static QueryBlockDetails intializeQueryBlockDetails(QueryStructure qs) {

		QueryBlockDetails qbt = new QueryBlockDetails();

		if(qs.isSetOp == false)
		{
			qbt.setProjectedCols(new ArrayList<Node>(qs.getProjectedCols()));
			qbt.setAggFunc(new ArrayList<AggregateFunction>(qs.getAggFunc()));
			qbt.setConjunctsQs(new ArrayList<ConjunctQueryStructure>(qs.getConjuncts()));
			qbt.setGroupByNodes(new ArrayList<Node>(qs.getGroupByNodes()));
			qbt.setNoOfGroups(qs.getGroupByNodes().size());
			qbt.setBaseRelations(new ArrayList<String>(qs.getQuery().getBaseRelation().values()));
			qbt.setOrderByNodes(new ArrayList<Node>(qs.getOrderByNodes()));
			qbt.setCaseConditionMap(new HashMap<Integer, CaseExpression>(qs.getCaseConditionMap()));
			qbt.setCaseConditionMap(new HashMap<Integer, CaseExpression>(qs.getCaseConditionMap()));
			// parismita - single level
			qbt.setLevel(qs.level);
			qbt.setLimit(qs.limit);
			// parismita - recursion on query blocks
			if (!qs.getWhereClauseSubqueries().isEmpty())
				qbt.getWhereClauseSubQueries().add(intializeQueryBlockDetails(qs.getWhereClauseSubqueries().get(0)));

			qbt.setHavingClause(qs.getHavingClause());
			if (qs.getIsDistinct())
				qbt.setDistinct(true);

			if (qbt.getHavingClause() != null)
				qbt.setConstrainedAggregation(true);

			qbt.setTopLevelRelation(qs.topLevelRelation);
		}
		else{
			qbt.setProjectedCols(new ArrayList<Node>(qs.getProjectedCols()));
			qbt.setConjunctsQs(new ArrayList<ConjunctQueryStructure>(qs.leftQuery.getConjuncts()));
			qbt.addConjunctsQs(qs.rightQuery.getConjuncts());
			qbt.setBaseRelations(new ArrayList<String>(qs.leftQuery.getQuery().getBaseRelation().values()));
			qbt.setTopLevelRelation(qs.leftQuery.topLevelRelation);

		}
		
		return qbt;
	}

	/**
	 * This method translates the given final count into number of tuples per base
	 * relation
	 * This method treats the nested sub query as a relation and assigns the number
	 * of tuples for subquery to the number of groups of the subquery
	 * 
	 * @param queryBlock
	 * @param rootTableName
	 * @return
	 */
	public static boolean getTupleAssignment(GenerateCVC1 cvc, QueryBlockDetails queryBlock, String rootTableName)
			throws Exception {

		/** get join conditions of this query block */
		Vector<Node> joinConds = new Vector<Node>();
		try {
			/**
			 * TODO: Which conjunct should be consider for the tuple assignment
			 * For now consider all the conjuncts, but incorrect
			 */
			for (ConjunctQueryStructure con : queryBlock.getConjunctsQs())
				for (Node n : con.getJoinCondsAllOther())
					joinConds.add(new Node(n));

			for (ConjunctQueryStructure con : queryBlock.getConjunctsQs())
				for (Node n : con.getJoinCondsForEquivalenceClasses())
					joinConds.add(new Node(n));

			/**
			 * If there are no join conditions or the final count is 1 , then we can
			 * directly assign the count to base relation
			 */
			if (joinConds == null || joinConds.size() == 0 || queryBlock.getFinalCount() == 1)
				return GetTupleAssignmentForQueryBlock.getTupleAssignmentWithoutJoins(cvc, queryBlock);

			return GetTupleAssignmentForQueryBlock.getTupleAsgnmentForQueryBlock(cvc, queryBlock, rootTableName);
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			return false;
			// throw e;
		}
	}

	public RelationHierarchyNode getTopLevelRelation() {
		return topLevelRelation;
	}

	public void setTopLevelRelation(RelationHierarchyNode topLevelRelation) {
		this.topLevelRelation = topLevelRelation;
	}

	/**
	 * A wrapper method to get constraints for all the blocks of the query
	 * 
	 * @author parismita
	 * @param cvc passing through event simulator now
	 * @return
	 * @throws Exception
	 */
	public static String getConstraintsForQueryBlock(GenerateCVC1 cvc) throws Exception {
		return TraverseNestedQueryBlock(cvc, cvc.getOuterBlock());
	}

	/**
	 * @author parismita
	 * @param cvc
	 * @param qb
	 * @return
	 * @throws Exception
	 */
	public static String TraverseNestedQueryBlock(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception {
		String constr = "";
		QueryBlockDetails s = qb;
		String aliasName = checkCurrentSubqueryLevelAlias(cvc, qb.getLevel()); // returns true only if current
																					// subquery is aliased

			if (qb.isDistinct) {
				// qb.putBaseSQRelations("DSQ" + qb.getLevel());
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("DSQ" + qb.getLevel());
				}

			} else if (isAggregationPresentInQuery(qb)) {
				// qb.putBaseSQRelations("GSQ" + qb.getLevel());// is it present in every level?
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("GSQ" + qb.getLevel());
				}
			} else {
				// qb.putBaseSQRelations("JSQ" + qb.getLevel());// what for GSQ??
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("JSQ" + qb.getLevel());
				}
			}

			// transformCondtitionAtGivenLevel(cvc,qb, aliasName);

		for (int i = 0; i < s.getWhereClauseSubQueries().size(); i++) {
			QueryBlockDetails n = s.getWhereClauseSubQueries().get(i);
			aliasName = checkCurrentSubqueryLevelAlias(cvc, n.getLevel()); // returns true only if current
			
			cvc.verticalLevelMap.put(n.getLevel(), s.getLevel());

			if (n.isDistinct) {
				qb.putBaseSQRelations("DSQ" + n.getLevel());
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("DSQ" + n.getLevel());
				}
			}
			else if (isAggregationPresentInQuery(n)){
				qb.putBaseSQRelations("GSQ" + n.getLevel());// is it present in every level?
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("GSQ" + n.getLevel());
				}
			}
			else{
				qb.putBaseSQRelations("JSQ" + n.getLevel());// what for GSQ??
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("JSQ" + n.getLevel());
				}
			}

			if (n.getWhereClauseSubQueries().size() > 0 || n.getFromClauseSubQueries().size() > 0) {
				constr += TraverseNestedQueryBlock(cvc, n);
			}
			
		}
		for (int i = 0; i < s.getFromClauseSubQueries().size(); i++) {
			QueryBlockDetails n = s.getFromClauseSubQueries().get(i);
			// qb.putBaseSQRelations("JSQ" + n.getLevel());// what for GSQ??
			// qb.putBaseSQRelations("GSQ" + n.getLevel());// is it present in every level?
			aliasName = checkCurrentSubqueryLevelAlias(cvc, n.getLevel()); // returns true only if current
			cvc.verticalLevelMap.put(n.getLevel(), s.getLevel());

			if (n.isDistinct) {
				qb.putBaseSQRelations("DSQ" + n.getLevel());
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("DSQ" + n.getLevel());
				}
			}
			else if (isAggregationPresentInQuery(n)){
				qb.putBaseSQRelations("GSQ" + n.getLevel());// is it present in every level?
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("GSQ" + n.getLevel());
				}
			}

			else{
				qb.putBaseSQRelations("JSQ" + n.getLevel());// what for GSQ??
				if (aliasName != null) {
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(aliasName);
					lvs.setRepSQTable("JSQ" + n.getLevel());
				}
			}

			if (n.getWhereClauseSubQueries().size() > 0 || n.getFromClauseSubQueries().size() > 0) {
				constr += TraverseNestedQueryBlock(cvc, n);
			}

		}
		constr += getConstraintsForQueryBlock(cvc, s);
		constr += "\n";

		return constr;
	}

	private static void transformCondtitionAtGivenLevel(GenerateCVC1 cvc, QueryBlockDetails qbt, String aliasName) {
		// TODO Auto-generated method stub
		ArrayList<ConjunctQueryStructure> cjs = qbt.getConjunctsQs();
		
		for(ConjunctQueryStructure c: cjs){
			Vector<Node> allConds = c.getAllConds();
			for(Node n: allConds){
				if(n.getLeft()!=null && n.getLeft().sqTableAliasName!=null){
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(n.getLeft().sqTableAliasName);
					Table sqTable = cvc.getTableMap().getSQTableByName(lvs.repSQTable);

				}

				if(n.getRight()!=null && n.getRight().sqTableAliasName!=null){
					levelStrcuture lvs = cvc.aliasMappingToLevels.get(n.getRight().sqTableAliasName);
					Table sqTable = cvc.getTableMap().getSQTableByName(lvs.repSQTable);
				}
			}
		}
		// throw new UnsupportedOperationException("Unimplemented method 'transformCondtitionAtGivenLevel'");
	}

	private static String checkCurrentSubqueryLevelAlias(GenerateCVC1 cvc, int level) {
		Iterator<Map.Entry<String, levelStrcuture>> iterator = cvc.aliasMappingToLevels.entrySet().iterator();

		while (iterator.hasNext()) {
			Map.Entry<String, levelStrcuture> entry = iterator.next();
			String key = entry.getKey();
			levelStrcuture lvs = entry.getValue();
			if (lvs.getIfSQTableAlias() && lvs.getSubqueryLevel() == level)
				return key;
		}

		return null;
		// throw new UnsupportedOperationException("Unimplemented method
		// 'checkCurrentSubqueryLevelAlias'");
	}

	/**
	 * @author Sunanda
	 * @param qs               QueryStructure
	 * @param fce              FromClauseElement
	 * @param aliasMapToLevels HashMap<String, Integer>
	 *                         Put the table aliases (unique table names) and level
	 *                         it belongs to, to a global hashmap
	 */
	public static void putFromClauseTablesInAliasMap(QueryStructure qs, FromClauseElement fce,
			HashMap<String, levelStrcuture> aliasMappingToLevels) {
		if (fce.getAliasName() == null && fce.getBag() == null)
			return;
		levelStrcuture lvs = new levelStrcuture(qs.getLevel(), fce.getSubQueryStructure() != null);
		if (fce.getSubQueryStructure() != null) {
			lvs.setSubqueryLevel(fce.getSubQueryStructure().getLevel());
		}

		if (fce.getTableNameNo() != null) {

			aliasMappingToLevels.put(fce.getTableNameNo().toLowerCase(), lvs);
		} else if (fce.getAliasName() != null) {
			aliasMappingToLevels.put(fce.getAliasName().toLowerCase(), lvs);

		}

		// recursive call for multiple elements in from clause bag
		if (fce.getBag() != null && fce.getBag().size() > 0) {
			for (FromClauseElement fceBag : fce.getBag())
				putFromClauseTablesInAliasMap(qs, fceBag, aliasMappingToLevels);
		}
	}
	public static void putNodeTablesInAliasMap(GenerateCVC1 cvc, QueryStructure qs, Node n) {
		levelStrcuture lvs = new levelStrcuture(qs.getLevel(), false);
		cvc.aliasMappingToLevels.put(n.getTableNameNo().toLowerCase(), lvs);
	}


	/**
	 * @author Sunanda
	 * @param cvc GenerateCVC1
	 * @param qs  QueryStructure
	 *            Traverse QueryStructure for correlation related operations
	 */
	public static void TraverseNestedQueryStrcuture(GenerateCVC1 cvc, QueryStructure qs) throws Exception {
		// traverse from clause element

		if (qs.getFromListElements().size() > 0) {
			for (FromClauseElement fce : qs.getFromListElements()) {
				// Put the table aliases (unique table names) and level it belongs to, to a
				// global hashmap
				putFromClauseTablesInAliasMap(qs, fce, cvc.aliasMappingToLevels);
			}
		}
		if(qs.aliasList!=null) for(Node n:qs.aliasList) putNodeTablesInAliasMap(cvc, qs, n);
		// build correlation details - put correlation structure in correlation map
		for (ConjunctQueryStructure cqs : qs.getConjuncts()) {
			buildCorrelationDetails(cvc, cqs, qs);
		}
		// traverse where clause subqueries
		for (int i = 0; i < qs.getWhereClauseSubqueries().size(); i++) {
			QueryStructure n = qs.getWhereClauseSubqueries().get(i);
			TraverseNestedQueryStrcuture(cvc, n);
		}
		// traverse from clause subqueries
		for (int i = 0; i < qs.getFromClauseSubqueries().size(); i++) {
			QueryStructure n = qs.getFromClauseSubqueries().get(i);
			TraverseNestedQueryStrcuture(cvc, n);
		}
		// level to query type hashmap built eg 0 - exist
		cvc.levelToQueryTypeHashMap.put(qs.level, qs.getQueryType().getType());

	}

	/**
	 * @author Sunanda
	 * @param conditionNode Node
	 * @param cvc           GenerateCVC1
	 * @param tables        Vector
	 *                      <table>
	 *                      : Base relations in particular queryblock
	 * @param subqueryType  String
	 * @param level         int
	 *                      Check if given condition is a correlation condition
	 *                      between two levels, if yes
	 *                      isCorrelated attributes is made true and corresponding
	 *                      level is assigned to nodes
	 */
	public static void isCorrelated(Node conditionNode, GenerateCVC1 cvc, Vector<Table> tables,
			String subqueryType, int level) {
		if (conditionNode.getRight() != null && conditionNode.getRight().getColumn() != null
				&& conditionNode.getLeft() != null && conditionNode.getLeft().getColumn() != null) {
			Node left = conditionNode.getLeft();
			Node right = conditionNode.getRight();

			if (subqueryType.equalsIgnoreCase("from")) // cant have correlation
				return;

			else if (subqueryType.equalsIgnoreCase("outer")) // cant have crrelation -> can have correlation change
																// FIXME by Sunanda
				return;

			else if (!(left.getType().equalsIgnoreCase(Node.getColRefType())
					|| left.getType().equalsIgnoreCase(Node.getAggrNodeType()))
					|| !(right.getType().equalsIgnoreCase(Node.getColRefType())
							|| right.getType().equalsIgnoreCase(Node.getAggrNodeType())))
				return;

			else {
				if(conditionNode.level!= null && conditionNode.level==-1) return;
				if(left.getTableAlias()==null) left.setTableAlias(left.getTableNameNo());
				if(right.getTableAlias()==null) right.setTableAlias(right.getTableNameNo());
				Boolean l = true, r = true;
				String rightTableName = right.getTableNameNo();
				String leftTableName = left.getTableNameNo();

				// if (left.getTable() != null)
				// 	leftTableName = left.getTable().getTableName();
				// if (right.getTable() != null)
				// 	rightTableName = right.getTable().getTableName();

				String leftTableAlias = leftTableName, rightTableAlias = rightTableName;
				if(left.getTableAlias()!=null && !left.getTableAlias().equalsIgnoreCase(""))
					leftTableAlias = left.getTableAlias();
				
				// else if(left.getTableAlias()==null || left.getTableAlias().equalsIgnoreCase(""))
				// 	leftTableAlias = left.getTableNameNo();

				if(right.getTableAlias()!=null && !right.getTableAlias().equalsIgnoreCase(""))
					rightTableAlias = right.getTableAlias();

				conditionNode.level = level;
				if(left.getTableAlias() != null&&cvc.aliasMappingToLevels.containsKey(left.getTableAlias().toLowerCase()))
				conditionNode.getLeft().level = (cvc.aliasMappingToLevels.get(left.getTableAlias().toLowerCase())
						.getQueryLevel());
				if(right.getTableAlias() != null&&cvc.aliasMappingToLevels.containsKey(right.getTableAlias().toLowerCase()))
				conditionNode.getRight().level = (cvc.aliasMappingToLevels.get(right.getTableAlias().toLowerCase())
						.getQueryLevel());
				
				

				if (left.getTable() != null)
					leftTableName = left.getTable().getTableName();
				if (right.getTable() != null)
					rightTableName = right.getTable().getTableName();

				for (Table t : tables) {
					if (t.getTableName().equalsIgnoreCase(leftTableName) && ((cvc.aliasMappingToLevels.get(leftTableAlias.toLowerCase())
									.getQueryLevel() == level)))
						l = false;
					if (t.getTableName().equalsIgnoreCase(rightTableName) && ((cvc.aliasMappingToLevels.get(rightTableAlias.toLowerCase())
									.getQueryLevel() == level)))
						r = false;
					if(!l && !r) break;
				}
				if (!l && !r) {
					conditionNode.isCorrelated = false;
					return;
				}

				if (l && r) {
					conditionNode.isCorrelated = true;
					return;
				}

				if (l) {
					conditionNode.isCorrelated = true;
					return;
				}

				if (r) {
					conditionNode.isCorrelated = true;
					return;
				}
				return;


			}

		}
		return;
	}

	/**
	 * @author Sunanda
	 * @param cvc GenerateCVC1
	 * @param cqs ConjunctQueryStructure
	 * @param qs  QueryStructure
	 *            Puts correlated conditions in a global structure called
	 *            correlationHashMap
	 * @throws CloneNotSupportedException
	 */
	private static void buildCorrelationDetails(GenerateCVC1 cvc, ConjunctQueryStructure cqs, QueryStructure qs)
			throws CloneNotSupportedException {
		// Collect tables presents in the current level for check correlated conditions
		Vector<Table> tables = new Vector<Table>();
		for (String baseRelations : qs.getLstRelations()) {
			Table cvcTable = cvc.getTableMap().getTable(baseRelations.replaceAll("\\d", "").toUpperCase());
			if (!tables.contains(cvcTable)) {
				tables.add(cvcTable);
			}
		}
		Node temp = null;
		Vector<Node> conds = new Vector<>();
		conds.addAll(cqs.getSelectionConds());
		conds.addAll(cqs.getJoinCondsForEquivalenceClasses());
		conds.addAll(cqs.getJoinCondsAllOther());


		for (Node n : conds) {
			isCorrelated(n, cvc, tables, "", qs.getLevel());
			if (cvc.currentMutant != null && cvc.currentMutant.getMutationTypeNumber() == 12
					&& ((Node) cvc.currentMutant.getMutationLoc()).equals(n)) {
				Node mutNode = (Node) cvc.currentMutant.getMutationNode();
				// Build correlation structure for correlated queries
				if (n.isCorrelated) {
					mutNode.isCorrelated = true;
					n.setOperator(mutNode.getOperator());
					temp = n.clone();
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			if (cvc.currentMutant != null && cvc.currentMutant.getMutationTypeNumber() == 10
					&& ((Node) cvc.currentMutant.getMutationLoc()).equals(n)) {
				Node mutNode = (Node) cvc.currentMutant.getMutationNode();
				// Build correlation structure for correlated queries
				if (n.isCorrelated) {
					mutNode.isCorrelated = true;
					n.setOperator(mutNode.getOperator());
					temp = n.clone();
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			// Check if the condition is correlated
			else {
				isCorrelated(n, cvc, tables, "", qs.getLevel());

				// Build correlation structure for correlated queries
				temp = n.clone();
				if (n.isCorrelated) {
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			n.setOrgiColumn(n.getColumn());
			if (n.getLeft() != null)
			n.getLeft().setOrgiColumn(n.getLeft().getColumn());
			if (n.getRight() != null)
			n.getRight().setOrgiColumn(n.getRight().getColumn());

		}
		for (Node n : cqs.getStringSelectionConds()) {
			isCorrelated(n, cvc, tables, "", qs.getLevel());
			if (n.isCorrelated) {
				temp = n.clone();
				correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
				cvc.correlationHashMap.put(n, cs);
			}
			n.setOrgiColumn(n.getColumn());
			if (n.getLeft() != null)
			n.getLeft().setOrgiColumn(n.getLeft().getColumn());
			if (n.getRight() != null)
				n.getRight().setOrgiColumn(n.getRight().getColumn());
		}

		for (Node n : cqs.getJoinCondsForEquivalenceClasses()) {
			isCorrelated(n, cvc, tables, "", qs.getLevel());
			if (cvc.currentMutant != null && cvc.currentMutant.getMutationTypeNumber() == 12
					&& ((Node) cvc.currentMutant.getMutationLoc()).equals(n)) {
				Node mutNode = (Node) cvc.currentMutant.getMutationNode();
				// Build correlation structure for correlated queries
				if (n.isCorrelated) {
					mutNode.isCorrelated = true;
					n.setOperator(mutNode.getOperator());
					temp = n.clone();
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			if (cvc.currentMutant != null && cvc.currentMutant.getMutationTypeNumber() == 10
					&& ((Node) cvc.currentMutant.getMutationLoc()).equals(n)) {
				Node mutNode = (Node) cvc.currentMutant.getMutationNode();
				// Build correlation structure for correlated queries
				if (n.isCorrelated) {
					mutNode.isCorrelated = true;
					n.setOperator(mutNode.getOperator());
					temp = n.clone();
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			// Check if the condition is correlated
			else {
				isCorrelated(n, cvc, tables, "", qs.getLevel());
				temp = n.clone();
				// Build correlation structure for correlated queries
				if (n.isCorrelated) {
					correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
					cs.setIsAggr(isAggregationPresentInQuery(qs));
					cvc.correlationHashMap.put(n, cs);
				}
			}
			n.setOrgiColumn(n.getColumn());
			if (n.getLeft() != null)
				n.getLeft().setOrgiColumn(n.getLeft().getColumn());
			if (n.getRight() != null)
				n.getRight().setOrgiColumn(n.getRight().getColumn());
		}
		for (Node n : cqs.getStringSelectionConds()) {
			isCorrelated(n, cvc, tables, "", qs.getLevel());
			if (n.isCorrelated) {
				temp = n.clone();
				correlationStructure cs = new correlationStructure(n, qs.getQueryType().getType());
				cvc.correlationHashMap.put(n, cs);
			}
			n.setOrgiColumn(n.getColumn());
			n.getLeft().setOrgiColumn(n.getLeft().getColumn());
			n.getRight().setOrgiColumn(n.getRight().getColumn());
		}
	}

	/**
	 * @author Sunanda
	 * @param cvc GenerateCVC1
	 *            Calculates the level at which correlation conditions to be
	 *            processed considering Exists and Not Exists types
	 */
	public static void setLevelForProcessingCorrelationCondition(GenerateCVC1 cvc) {
		for (Node n : cvc.correlationHashMap.keySet()) {
			correlationStructure cs = cvc.correlationHashMap.get(n);
			if (cs!=null&&cs.getCondition() != null && cs.getCondition().getLeft() != null
					&& cs.getCondition().getRight() != null) {
				int leftLevel = cs.getCondition().getLeft().getLevel();
				int rightLevel = cs.getCondition().getRight().getLevel();
				int nodelevel = cs.getCondition().getLevel();
				cs.setOriginalLevelLeft(leftLevel);
				cs.setOriginalLevelRight(rightLevel);
				// process level for exists is minimum of levels at which right and left nodes
				// belong
				if(cs.getQueryType() == null)
					cs.setQueryType("FROM");

				if (cs.getQueryType().equalsIgnoreCase("EXISTS"))
					cs.setProcessLevel(Math.min(leftLevel, rightLevel));
				
				if (cs.getQueryType().equalsIgnoreCase("FROM"))
					cs.setProcessLevel(Math.min(Math.min(leftLevel, rightLevel), nodelevel));

				// process and pushdown level set
				// parismita - adding non equijoin condition
				else if (cs.getQueryType().equalsIgnoreCase("NOT EXISTS") || cs.getIsEquiJoin() == false
						|| cs.isAggr == true) {
					int pLevel = 1;
					for (int i = cs.getCondition().getLevel() - 1; i > 0; i--) { // current level -1
						if (cvc.levelToQueryTypeHashMap.get(i).equalsIgnoreCase("EXISTS"))
							pLevel = i;// nearest exist level
					}
					cs.setProcessLevel(Math.min(leftLevel, rightLevel));
					if (cs.isAggr == true)
						pLevel = cs.getCondition().getLevel();
					if (!(rightLevel - leftLevel == 1 || rightLevel - leftLevel == -1) || cs.isAggr == true)
						cs.setPushTableDownLevel(Math.max(Math.min(leftLevel, rightLevel), pLevel));
				}
			}
		}
	}

	/**
	 * This method is used to get constraints for all the conditions involved in
	 * this query block, including from clause sub query blocks, if any
	 * 
	 * @param qb
	 * @param cvc
	 */
	public static String getConstraintsForQueryBlock(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception {

		String constraintString = "";
		try {
			/* Constraints for having clause */

			constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF THIS BLOCK ");

			constraintString += ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY BLOCK ");

			constraintString += addFromClauseSubqueryRelatedConstraints(cvc, qb);

			constraintString += ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY BLOCK ");

			// unchanged - works for where clause subqueries
			constraintString += getConstraintsForQueryBlockExceptSubQuries(cvc, qb);

			constraintString += ConstraintGenerator.addCommentLine(" WHERE CLAUSE SUBQUERY BLOCK ");

			constraintString += addWhereClauseSubqueryRelatedConstraints(cvc, qb);

			constraintString += ConstraintGenerator.addCommentLine(" END OF WHERE CLAUSE SUBQUERY BLOCK ");

			constraintString += ConstraintGenerator.addCommentLine(" OUTER QUERY AS SUBQUERY BLOCK ");

			constraintString += driverAddOuterQueryAsSubqueryConstraints(cvc, qb);

			constraintString += ConstraintGenerator.addCommentLine(" END OF OUTER QUERY AS SUBQUERY BLOCK ");
			
			// reset hashmap - ??

			constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF THIS BLOCK ");

			// recursion - parismita

		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}

		return constraintString;

	}

	public static void addToMap(GenerateCVC1 cvc, String key, Column value) {
	// Check if the key exists in the map
	if (cvc.forMap.containsKey(key)) {
		// Key exists, retrieve the vector and add the new object
		cvc.forMap.get(key).add(value);
	} else {
		// Key does not exist, create a new vector, add the object, and put it in the map
		Vector<Column> vector = new Vector<>();
		vector.add(value);
		cvc.forMap.put(key, vector);
	}
	}


	private static HashMap<String, Object> createTempSetTables(GenerateCVC1 cvc, String joinTable, 
	Vector<Table> tables, String sqType) throws Exception {
		
		HashMap<String, Object> columnNameAndDataTypes = new HashMap<String, Object>();
		ArrayList<String> columns = new ArrayList<String>();
		ArrayList<Sort> columnDataTypes = new ArrayList<Sort>();
		ArrayList<String> primaryKey = new ArrayList<String>();
		String columnName = "";
		Table sqi = new Table(joinTable);
		Map<String, Table> tableMap = new HashMap<String, Table>();
		Vector<String> countColumnsOfBaseTables = new Vector<String>();

		ArrayList<Node> projectedColNodes =cvc.getqStructure().lstProjectedCols;		
		int index=0;
		for(Node x : projectedColNodes)
		{
			columnName = joinTable + "_" + x.getColumn().getColumnName() + String.valueOf(index);
			//columnName = joinTable + "_" + tables.get(0).getTableName() + "__" + x.getColumn().getColumnName() + String.valueOf(index);

			columns.add(columnName);
		
			String getColName = "JSQL0_" + x.getColumn().getTableName() + "__" +x.getColumn().getColumnName() + cvc.getTableMap().getTable(x.getColumn().getTableName().toUpperCase()).getColumnIndex(x.getColumn().getColumnName());
			Column corrColumn = cvc.getTableMap().getSQTables().get("JSQL0").getColumn(getColName);

			cvc.getTableMap().getSQTables().get("JSQL0").getColumn(getColName).isProjected=1;
			
			columnDataTypes.add(ConstraintGenerator.getColumnSort(corrColumn.getCvcDatatype()));

			int flag = 0;
			if (tables.get(0).getPrimaryKey().contains(corrColumn)) {
				primaryKey.add(columnName);
				flag = 1;
			}
			Column col = new Column(corrColumn);
			col.setColumnName(columnName);
			col.setTableName(joinTable);
			col.setTable(sqi);
			col.setBaseRelation(tables.get(0).getTableName());
			col.isProjected =1;
			sqi.addColumn(col);

			if (flag == 1)
				sqi.addColumnInPrimaryKey(col);
			

			index++;
		}

		for (Table t : tables) {
			Column lastColumn = t.getLastColumnValue();

			String join = joinTable;

				
			String lastColumnName = join +"_" + t.getLastColumnKey() + String.valueOf(index);

			columns.add(lastColumnName);

			Column col = new Column(lastColumn);
			col.setColumnName(lastColumnName);
			col.setTableName(joinTable);
			col.setTable(sqi);
			col.setBaseRelation(t.getTableName());
			sqi.addColumn(col);

			if (lastColumnName.contains("XDATA_CNT"))
				countColumnsOfBaseTables.add(lastColumnName);

			columnDataTypes.add(ConstraintGenerator.ctx.getIntSort());

			index ++;
			
		}

		if (Configuration.getProperty("cntFlag").equalsIgnoreCase("true")) {
			columns.add(joinTable + "__XDATA_CNT");
			columnDataTypes.add(ConstraintGenerator.ctx.getIntSort());
			Column col = new Column(joinTable + "__XDATA_CNT", sqi);
			col.setDataType(4);// INT
			col.setCvcDatatype("INT");
			col.setColumnSize(0);
			sqi.addColumn(col);
			countColumnsOfBaseTables.add(joinTable + "__XDATA_CNT");
		}

		sqi.setSQType(sqType);
		tableMap.put(joinTable, sqi);
		columnNameAndDataTypes.put("Names", columns);
		columnNameAndDataTypes.put("DataTypes", columnDataTypes);
		columnNameAndDataTypes.put("PrimaryKey", primaryKey);
		columnNameAndDataTypes.put("TableMap", tableMap);
		columnNameAndDataTypes.put("CountColumns", countColumnsOfBaseTables);

			
		return columnNameAndDataTypes;
	}

	private static String driverAddOuterQueryAsSubqueryConstraints(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception 
	{
		if(cvc.getqStructure().isSetOp == false)
		{
			String constraintString = addOuterQueryAsSubqueryConstraints(cvc,qb);
			return constraintString;
		}
		else
		{
			String constraintString = addOuterQueryAsSubqueryConstraintsForSetOps(cvc,cvc.outerBlockL,cvc.outerBlockR);
			return constraintString;
		}

	}

	
	public static String createSetOpHeader(GenerateCVC1 cvc, QueryBlockDetails qbl, QueryBlockDetails qbr) throws Exception 
	{
		String constraintString = "";

		qbl.setNo=0;

		constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF LEFT");

		joinSubqueryConstraintsForFromClauseSubquery(cvc, qbl, "outer");

		if (cvc.subqueryConstraintsMap.size() > 0 &&cvc.subqueryConstraintsMap.containsKey("JSQL0")&& !cvc.subqueryConstraintsMap.get("JSQL0").SQDefine.isEmpty()) {
			String constr = "";
			for (String key : cvc.subqueryConstraintsMap.get("JSQL0").SQDefine.keySet()) {
				String joinTable = key;
				Vector<Node> correlationConds = cvc.subqueryConstraintsMap.get("JSQL0").SQJoinCorrelationConds
						.get(joinTable);
				constr += cvc.subqueryConstraintsMap.get("JSQL0").SQDefine.get(joinTable);// mapping
				
				if (Configuration.outerSQ.equalsIgnoreCase("false")) {
					constr += GenerateJoinPredicateConstraints.generateConstraintsForCorrelationAttributes(cvc,
							joinTable, correlationConds, qbl.getLevel()) + "\n";
				}

			}
			constraintString += constr;
		}
		constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF LEFT");

		//System.out.println(constraintString);

		qbr.setNo=1;
		constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF RIGHT");

		joinSubqueryConstraintsForFromClauseSubquery(cvc, qbr, "outer");


		if (cvc.subqueryConstraintsMap.size() > 0 &&cvc.subqueryConstraintsMap.containsKey("JSQR0")&& !cvc.subqueryConstraintsMap.get("JSQR0").SQDefine.isEmpty()) {
			String constr = "";
			for (String key : cvc.subqueryConstraintsMap.get("JSQR0").SQDefine.keySet()) {
				String joinTable = key;
				Vector<Node> correlationConds = cvc.subqueryConstraintsMap.get("JSQR0").SQJoinCorrelationConds
						.get(joinTable);
				constr += cvc.subqueryConstraintsMap.get("JSQR0").SQDefine.get(joinTable);// mapping
				
				if (Configuration.outerSQ.equalsIgnoreCase("false")) {
					constr += GenerateJoinPredicateConstraints.generateConstraintsForCorrelationAttributes(cvc,
							joinTable, correlationConds, qbl.getLevel()) + "\n";
				}

			}
			constraintString += constr;
		}
		constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF RIGHT");

		// DECLARE THE SETOP RELATION -------------------------------------------------

		constraintString += ConstraintGenerator.addCommentLine(" DEFINE THE RELATION FOR SETOP");
		String joinTable = "SETOP" + String.valueOf(cvc.setOpNo);
		cvc.setOpJoin = joinTable;
		cvc.setOpNo+=1;

		Collection<Table> sqTables = cvc.getTableMap().getSQTables().values();
		Vector<Table> sqTableList = new Vector<>(sqTables);
		Vector<String> sqTableListNames = new Vector<>();
		for(Table i : sqTableList)
		{
			sqTableListNames.add(i.getTableName());
		}

		String indexType = "Int";

		HashMap<String, Object> jtColumnNamesAndDataTypes = createTempSetTables(cvc, joinTable, sqTableList,
				"outer");
		
		cvc.jtObj.put(joinTable,jtColumnNamesAndDataTypes);

		ArrayList<String> jtColumns = (ArrayList<String>) jtColumnNamesAndDataTypes.get("Names");
		ArrayList<Sort> jtColumnDataTypes = (ArrayList<Sort>) jtColumnNamesAndDataTypes.get("DataTypes");
		ArrayList<String> primaryKeyOfJoinTable = (ArrayList<String>) jtColumnNamesAndDataTypes.get("PrimaryKey");
		if (cvc.getTableMap().getSQTables() == null)
			cvc.getTableMap().setSQTables((Map<String, Table>) jtColumnNamesAndDataTypes.get("TableMap"));
		else
			cvc.getTableMap().putSQTables((Map<String, Table>) jtColumnNamesAndDataTypes.get("TableMap"));
		Table sqTable = cvc.getTableMap().getSQTableByName(joinTable);


		String tempConstraints = "";
		Expr aex = ConstraintGenerator.putTableInCtx(cvc,
				jtColumns.toArray(new String[jtColumns.size()]),
				jtColumnDataTypes.toArray(new Sort[jtColumnDataTypes.size()]),
				joinTable); 

		for (String statement : ConstraintGenerator.declareRelation(aex)) {
			if(statement.contains("declare-datatypes ((JSQL0_TupleType 0))") || statement.contains("declare-datatypes ((JSQR0_TupleType 0))") || statement.contains("declare-fun O_JSQR0 ()") || statement.contains("declare-fun O_JSQL0 ()"))
				continue;
			else
			tempConstraints += statement;
		}

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END DEFINE THE RELATION FOR SETOP");

		
		constraintString += ConstraintGenerator.addCommentLine(" BEGIN PK FOR SETOP");

		Vector<String> cntColumnNames = new Vector<String>();
		cntColumnNames = (Vector<String>) jtColumnNamesAndDataTypes.get("CountColumns");

		
		Expr cntOfSQColumnSQi1 = ConstraintGenerator.genSelectTest2(cvc, joinTable,
		jtColumns.indexOf(cntColumnNames.get(cntColumnNames.size() - 1)), "i1");
		Expr cntOfSQColumnSQj1 = ConstraintGenerator.genSelectTest2(cvc, joinTable,
				jtColumns.indexOf(cntColumnNames.get(cntColumnNames.size() - 1)), "j1");

		Expr orAndPK;

		if(cvc.getqStructure().setOperator=="EXCEPT" || (cvc.getCurrentMutant()!=null && 
		(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT") || cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")))) 
		{
			orAndPK = ConstraintGenerator.ctx.mkAnd(
				ConstraintGenerator.ctx.mkEq((ArithExpr) cntOfSQColumnSQi1,
						(ArithExpr) ConstraintGenerator.ctx.mkInt(0)),
				ConstraintGenerator.ctx.mkEq((ArithExpr) cntOfSQColumnSQj1,
						(ArithExpr) ConstraintGenerator.ctx.mkInt(0)));
		}
		else
		{
			orAndPK = ConstraintGenerator.ctx.mkOr(
				ConstraintGenerator.ctx.mkEq((ArithExpr) cntOfSQColumnSQi1,
						(ArithExpr) ConstraintGenerator.ctx.mkInt(0)),
				ConstraintGenerator.ctx.mkEq((ArithExpr) cntOfSQColumnSQj1,
						(ArithExpr) ConstraintGenerator.ctx.mkInt(0)));
		}
		BoolExpr[] andexprConstraintsTemp = new BoolExpr[primaryKeyOfJoinTable.size() + 1];
		int p = 0;
		for (int i = 0; i < primaryKeyOfJoinTable.size(); i++) {
			Expr selecti1 = ConstraintGenerator.genSelectTest2(cvc, joinTable,
					jtColumns.indexOf(primaryKeyOfJoinTable.get(i)), "i1");
			;
			Expr selectj1 = ConstraintGenerator.genSelectTest2(cvc, joinTable,
					jtColumns.indexOf(primaryKeyOfJoinTable.get(i)), "j1");
			;
			andexprConstraintsTemp[p] = (BoolExpr) ConstraintGenerator.ctx.mkEq(selecti1, selectj1);
			p++;
		}
		andexprConstraintsTemp[p] = ConstraintGenerator.ctx.mkNot(ConstraintGenerator.ctx.mkEq(
				(Expr) ConstraintGenerator.ctx.mkIntConst("i1"), (Expr) ConstraintGenerator.ctx.mkIntConst("j1")));
		Expr andExprTempForPK = ConstraintGenerator.ctx.mkAnd(andexprConstraintsTemp);

		tempConstraints = "\n(assert (forall ((i1 " + indexType + ") (j1 " + indexType + ")) \n\t (=> \n\t"
				+ andExprTempForPK.toString()
				+ "\n\t\t" + orAndPK + ")))\n\n";

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END PK FOR SETOP");
		

		constraintString += ConstraintGenerator.addCommentLine(" BEGIN MAPPING FOR SETOP");

		getColumnsForMapping(cvc);
		tempConstraints="";

		for(String joinTablesLR: sqTableListNames)
		{
			int joincol = 0;
			
			String fun = ("define-fun " + joinTable + "_map_" + joinTablesLR+ "((x!0 " + indexType + ") (x!1 "
					+ indexType + ")) Bool\n");

			tempConstraints += "\n(" + fun + "(and \n";
			int col1 = 0;

			while (col1 < cvc.forMap.get(joinTablesLR).size()) {
				int index = cvc.getTableMap().getSQTableByName(joinTablesLR).getColumnIndex(cvc.forMap.get(joinTablesLR).get(col1).getColumnName());

				String colName = cvc.getTableMap().getSQTableByName(joinTablesLR).getColumn(index).getColumnName().split("\\d$")[0];

				Vector<String> corrIndexList = sqTable.getColumnIndexList();

				for(String str : corrIndexList)
				{
					String str_temp=str.split(joinTable+"_")[1].split("\\d$")[0];

					if(colName.contains(str_temp))
					{
						
						joincol = Integer.parseInt(str.substring(str.length() -1));
						break;
					}
				}

				Expr left = ConstraintGenerator.genSelectTest2(cvc, joinTablesLR,
						index , "x!0");
				Expr right = ConstraintGenerator.genSelectTest2(cvc, joinTable, joincol, "x!1");
				Expr eq = ConstraintGenerator.ctx.mkEq(left, right);
				tempConstraints += eq.toString() + "\n";
				col1++;
				joincol++;
			}
			tempConstraints += ")\n)\n";

		}


		constraintString+=tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END MAPPING FOR SETOP");

		if(cvc.getqStructure().isSetOp == true)
		{
			int count =0;
			if(cvc.getqStructure().setOperator == "UNION" || cvc.getqStructure().setOperator == "UNION ALL")
			{
				count = cvc.getNoOfTuples().get("JSQL0") + cvc.getNoOfTuples().get("JSQR0");
			}

			if(cvc.getqStructure().setOperator == "INTERSECT" || cvc.getqStructure().setOperator == "INTERSECT ALL")
			{
				count = Math.min(cvc.getNoOfTuples().get("JSQL0") ,cvc.getNoOfTuples().get("JSQR0") );
			}

			if(cvc.getqStructure().setOperator == "EXCEPT" || cvc.getqStructure().setOperator == "EXCEPT ALL")
			{
				count = cvc.getNoOfTuples().get("JSQL0") ;
			}

			cvc.putNoOfOutputTuples(joinTable, count);
		}

		constraintString += ConstraintGenerator.addCommentLine(" BEGIN CONSTRAINTS FOR SETOP FWD PASS");
				
		tempConstraints = "";

		for(int j=0 ; j<sqTableListNames.size() ; j++)
		{
			

			String tempConstraints_ = "";

			String tableCond = "";

			String impliesSelect ="(=> (> " + ConstraintGenerator.genSelectTest2(cvc, sqTableListNames.get(j) , cvc.getTableMap().getSQTableByName(sqTableListNames.get(j)).getNoOfColumn()-1 , "i1").toString() + " 0)";
		

			for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
			{
				tableCond = "(" + joinTable + "_map_" + sqTableListNames.get(j) + " i1 " + String.valueOf(i+1) + ")\n";

				tempConstraints_ += "\t"  + tableCond +  "\n";

				
			}
			tempConstraints += "(assert (forall ((i1 Int))\n" + impliesSelect + "\n" + "  (or\n" + tempConstraints_ + "\n)\n)))\n";
		}
		

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END CONSTRAINTS FOR SETOP FWD PASS");

		constraintString += ConstraintGenerator.addCommentLine(" BEGIN CONSTRAINTS FOR SETOP BWD PASS FOR LEFT");

		tempConstraints = "";


		Expr cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "u");
				
		Expr cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints += "(=> " + cntGtCheck.toString() +"\n\t(and ";

		cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "u");
				
		cntGtCheck = ConstraintGenerator.ctx.mkGe((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints+= cntGtCheck.toString() + "\n";

		cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints += "\t(=> " + cntGtCheck.toString() + "\n";

	

		String tableCond = "";

		String tempConstraints_ =""; 

		tempConstraints += "\n\t(or\n";
		for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		{
			tableCond = "(" + joinTable + "_map_" + sqTableListNames.get(0) +  " " + String.valueOf(i+1) + " " + "u" + ")\n";

			tempConstraints_ += "\t" + tableCond;

			tempConstraints_ += "\t" + "\n";
		}

		tempConstraints +=  tempConstraints_ + ")";

	

		tempConstraints = "(assert (forall ((u Int))\n" + tempConstraints + ")))))" ;
		

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END CONSTRAINTS FOR SETOP BWD PASS FOR LEFT");


		constraintString += ConstraintGenerator.addCommentLine(" BEGIN CONSTRAINTS FOR SETOP BWD PASS FOR RIGHT");

		tempConstraints = "";


		cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "u");
				
		cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints += "(=> " + cntGtCheck.toString() +"\n\t(and ";

		cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "u");
				
		cntGtCheck = ConstraintGenerator.ctx.mkGe((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints+= cntGtCheck.toString() + "\n";

		cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		tempConstraints += "\t(=> " + cntGtCheck.toString() + "\n";

		
		tableCond = "";
		tempConstraints_ =""; 

		tempConstraints += "\n\t(or\n";
		for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		{
			tableCond = "(" + joinTable + "_map_" + sqTableListNames.get(1) +  " " + String.valueOf(i+1) + " " + "u" + ")\n";

			tempConstraints_ += "\t" + tableCond;

			tempConstraints_ += "\t" + "\n";
		}

		tempConstraints +=  tempConstraints_ + ")";

	

		tempConstraints = "(assert (forall ((u Int))\n" + tempConstraints + ")))))" ;
		

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END CONSTRAINTS FOR SETOP BWD PASS FOR RIGHT");

		//with ite
		// constraintString += ConstraintGenerator.addCommentLine(" BEGIN CONSTRAINTS FOR SETOP BWD PASS FOR LEFT");

		// tempConstraints = "";


		// Expr cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "u");
				
		// Expr cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints += "(=> " + cntGtCheck.toString() +"\n\t(and ";

		// cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "u");
				
		// cntGtCheck = ConstraintGenerator.ctx.mkGe((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints+= cntGtCheck.toString() + "\n";

		// cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints += "\t(ite " + cntGtCheck.toString() + "\n";

	

		// String tableCond = "";

		// String tempConstraints_ =""; 

		// tempConstraints += "\n\t(or\n";
		// for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		// {
		// 	tableCond = "(" + joinTable + "_map_" + sqTableListNames.get(0) +  " " + String.valueOf(i+1) + " " + "u" + ")\n";

		// 	tempConstraints_ += "\t" + tableCond;

		// 	tempConstraints_ += "\t" + "\n";
		// }

		// tempConstraints +=  tempConstraints_ + ")";

	

		// tempConstraints = "(assert (forall ((u Int))\n" + tempConstraints + "true)))))" ;
		

		// constraintString += tempConstraints;

		// constraintString += ConstraintGenerator.addCommentLine(" END CONSTRAINTS FOR SETOP BWD PASS FOR LEFT");


		// constraintString += ConstraintGenerator.addCommentLine(" BEGIN CONSTRAINTS FOR SETOP BWD PASS FOR RIGHT");

		// tempConstraints = "";


		// cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "u");
				
		// cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints += "(=> " + cntGtCheck.toString() +"\n\t(and ";

		// cntCheckExpr = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "u");
				
		// cntGtCheck = ConstraintGenerator.ctx.mkGe((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints+= cntGtCheck.toString() + "\n";

		// cntGtCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntCheckExpr, ConstraintGenerator.ctx.mkInt(0));

		// tempConstraints += "\t(ite " + cntGtCheck.toString() + "\n";

		
		// tableCond = "";
		// tempConstraints_ =""; 

		// tempConstraints += "\n\t(or\n";
		// for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		// {
		// 	tableCond = "(" + joinTable + "_map_" + sqTableListNames.get(1) +  " " + String.valueOf(i+1) + " " + "u" + ")\n";

		// 	tempConstraints_ += "\t" + tableCond;

		// 	tempConstraints_ += "\t" + "\n";
		// }

		// tempConstraints +=  tempConstraints_ + ")";

	

		// tempConstraints = "(assert (forall ((u Int))\n" + tempConstraints + "true)))))" ;
		

		// constraintString += tempConstraints;

		// constraintString += ConstraintGenerator.addCommentLine(" END CONSTRAINTS FOR SETOP BWD PASS FOR RIGHT");

		return constraintString;
	}

	private static String getXDATACNT(GenerateCVC1 cvc) throws Exception 
	{
		String constraintString="";
		String tempConstraints="";
		String joinTable = cvc.setOpJoin;

		switch (cvc.getqStructure().setOperator) 
		{
			case "UNION":
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints = "(assert (forall ((i1 Int))\n (= ";
				

				Expr selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += selectU.toString() + " ";

				tempConstraints += "(ite (or  ";

				Expr cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
				Expr cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

				Expr cnEqCheck1 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprL, ConstraintGenerator.ctx.mkInt(0));
				Expr cnEqCheck2 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprR, ConstraintGenerator.ctx.mkInt(0));

				tempConstraints += cnEqCheck1.toString() + " " + cnEqCheck2.toString() + " ) " + "1 0" + " )" ;


				tempConstraints += " ) \n) ) ";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");
				
				break;
			
			case "UNION ALL":
				
				
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints="(assert (forall ((i1 Int))\n";

				cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");

				cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
				
				String sumExpr = "( +" + cntExprL.toString() + cntExprR.toString() + ")";

				selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += "(= " + selectU.toString() + sumExpr.toString() + ")\n))";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");				
				

				break;
			case "INTERSECT":

				if(cvc.isAll==0)
				{
					constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					tempConstraints = "(assert (forall ((i1 Int))\n (= ";
					

					selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					tempConstraints += selectU.toString() + " ";

					tempConstraints += "(ite (and  ";

					cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
					cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

					cnEqCheck1 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprL, ConstraintGenerator.ctx.mkInt(0));
					cnEqCheck2 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprR, ConstraintGenerator.ctx.mkInt(0));

					tempConstraints += cnEqCheck1.toString() + " " + cnEqCheck2.toString() + " ) " + "1 0" + " )" ;


					tempConstraints += " ) \n) ) ";

					constraintString+=tempConstraints;

					constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

				}

				else
				{
					// constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					// tempConstraints="(assert (forall ((i1 Int))\n";

					// Expr selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					// Expr selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
					// Expr selRightGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));

					// Expr selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
					// Expr selLeftGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));

					// tempConstraints+="( = " + selSetOp.toString() + "\n(ite\n\t";

					// tempConstraints += "( and (>" + selRight.toString() + selLeft.toString() + ") " + selLeftGt.toString() + ")\n";

					// tempConstraints+=selLeft.toString() + "\n";

					// tempConstraints += "(ite (and (<= "+ selRight.toString() + selRight.toString() + " ) " + selRightGt.toString() + ")\n";

					// tempConstraints+=selRight.toString() + " 0 )\n)\n)))";

					// constraintString+=tempConstraints;
					
					// constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

					constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					tempConstraints="(assert (forall ((i1 Int))\n\t";

					Expr selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					Expr selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
					Expr selRightGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));

					Expr selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
					Expr selLeftGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));

					tempConstraints += "( and \n\t\t";
					tempConstraints += "(=> " + "( and (>" + selRight.toString() + selLeft.toString() + ") " + selLeftGt.toString() + ")\n \t\t\t " + " ( = " +selSetOp.toString() + selLeft.toString() + " )\n\t\t)\n\t\t";
					tempConstraints += "(=> " + "( and (<=" + selRight.toString() + selLeft.toString() + ") " + selRightGt.toString() + ")\n \t\t\t " + " ( = " +selSetOp.toString() + selRight.toString() + " )\n\t\t)\n\t\t";
					tempConstraints += "(=> " + "( or (=" + selLeft.toString() + " 0 )" + " ( = " + selRight.toString() +  " 0 ))\n\t\t\t ( = " + selSetOp.toString() + " 0 )\n\t\t)\n\t)\n))";
				

					constraintString+=tempConstraints;
					
					constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");
					
				}
				
				break;
			
			
			case "EXCEPT":

				if(cvc.isAll==0)
				{

					constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					tempConstraints = "(assert (forall ((i1 Int))\n (= ";
					

					selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					tempConstraints += selectU.toString() + " ";

					tempConstraints += "(ite ";

					cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
					cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");

					
					

					tempConstraints += "(>(-" + cntExprL.toString() + cntExprR.toString() + ")0)" + " "  + "1 0" + " )" ;


					tempConstraints += " ) \n) ) ";

					constraintString+=tempConstraints;

					constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");
	

				}
				else
				{
					// constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					// Expr selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					// Expr selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
					// Expr selRightGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));

					// Expr selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
					// Expr selLeftGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));

					// tempConstraints =" (assert (forall ((i1 Int))\n";

					// tempConstraints += "(= " + selSetOp.toString() + "\n";

					// tempConstraints += "\t(ite \n \t\t( > ( - " + selLeft.toString() + " " + selRight.toString() + ") 0 )\n\t\t\t";

					// tempConstraints+= "(- " + selLeft.toString() + selRight.toString() + " ) 0 )\n)))";

					// constraintString+=tempConstraints;

					constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

					Expr selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

					Expr selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
					
					Expr selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

					tempConstraints ="(assert (forall ((i1 Int))\n\t(and\n\t\t";

					tempConstraints += "(=> ( >" + "( - " + selLeft.toString() + " " + selRight.toString() + ") 0 )\n\t\t\t";

					tempConstraints += "( = " + selSetOp.toString() + "( - " + selLeft.toString() + " " + selRight.toString() + "))\n\t\t)\n\t\t" ;

					tempConstraints += "(=> ( <=" + "( - " + selLeft.toString() + " " + selRight.toString() + ") 0 )\n\t\t\t";

					tempConstraints += "( = " + selSetOp.toString() +  "0)\n\t\t)\n\t" ;

					tempConstraints += ")\n))";

					constraintString+=tempConstraints;

					
					constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

					
				}
				default:
					break;
		}
		return constraintString;
	}
	
	private static String getXDATACNT(GenerateCVC1 cvc, String op) throws Exception 
	{
		String constraintString="";
		String tempConstraints="";
		String joinTable = cvc.setOpJoin;

		switch (op) 
		{
			case "UNION":
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints = "(assert (forall ((i1 Int))\n (= ";
				

				Expr selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += selectU.toString() + " ";

				tempConstraints += "(ite (or  ";

				Expr cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
				Expr cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

				Expr cnEqCheck1 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprL, ConstraintGenerator.ctx.mkInt(0));
				Expr cnEqCheck2 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprR, ConstraintGenerator.ctx.mkInt(0));

				tempConstraints += cnEqCheck1.toString() + " " + cnEqCheck2.toString() + " ) " + "1 0" + " )" ;


				tempConstraints += " ) \n) ) ";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");
				
				break;
			
			case "UNION ALL":
				
				
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints="(assert (forall ((i1 Int))\n";

				cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");

				cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
				
				String sumExpr = "( +" + cntExprL.toString() + cntExprR.toString() + ")";

				selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += "(= " + selectU.toString() + sumExpr.toString() + ")\n))";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");				
				

				break;
			case "INTERSECT":

				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints = "(assert (forall ((i1 Int))\n (= ";
				

				selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += selectU.toString() + " ";

				tempConstraints += "(ite (and  ";

				cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
				cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

				cnEqCheck1 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprL, ConstraintGenerator.ctx.mkInt(0));
				cnEqCheck2 = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExprR, ConstraintGenerator.ctx.mkInt(0));

				tempConstraints += cnEqCheck1.toString() + " " + cnEqCheck2.toString() + " ) " + "1 0" + " )" ;


				tempConstraints += " ) \n) ) ";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

				break;

			case "INTERSECT ALL":
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints="(assert (forall ((i1 Int))\n\t";

				Expr selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				Expr selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
				Expr selRightGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));

				Expr selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
				Expr selLeftGt = ConstraintGenerator.ctx.mkGt((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));

				tempConstraints += "( and \n\t\t";
				tempConstraints += "(=> " + "( and (>" + selRight.toString() + selLeft.toString() + ") " + selLeftGt.toString() + ")\n \t\t\t " + " ( = " +selSetOp.toString() + selLeft.toString() + " )\n\t\t)\n\t\t";
				tempConstraints += "(=> " + "( and (<=" + selRight.toString() + selLeft.toString() + ") " + selRightGt.toString() + ")\n \t\t\t " + " ( = " +selSetOp.toString() + selRight.toString() + " )\n\t\t)\n\t\t";
				tempConstraints += "(=> " + "( or (=" + selLeft.toString() + " 0 )" + " ( = " + selRight.toString() +  " 0 ))\n\t\t\t ( = " + selSetOp.toString() + " 0 )\n\t\t)\n\t)\n))";
			

				constraintString+=tempConstraints;
				
				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

				break;
			
			case "EXCEPT":

				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				tempConstraints = "(assert (forall ((i1 Int))\n (= ";
				

				selectU = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				tempConstraints += selectU.toString() + " ";

				tempConstraints += "(ite ";

				cntExprL = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");
				cntExprR = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");		

				tempConstraints += "(>(-" + cntExprL.toString() + cntExprR.toString() + ")0)" + " "  + "1 0" + " )" ;


				tempConstraints += " ) \n) ) ";

				constraintString+=tempConstraints;

				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");		
				
				break;
			
			case "EXCEPT ALL":
				constraintString += ConstraintGenerator.addCommentLine(" BEGIN XDATA CALC");

				selSetOp =  ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , "i1");

				selRight = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , "i1");
				
				selLeft = ConstraintGenerator.genSelectTest2(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , "i1");

				tempConstraints ="(assert (forall ((i1 Int))\n\t(and\n\t\t";

				tempConstraints += "(=> ( >" + "( - " + selLeft.toString() + " " + selRight.toString() + ") 0 )\n\t\t\t";

				tempConstraints += "( = " + selSetOp.toString() + "( - " + selLeft.toString() + " " + selRight.toString() + "))\n\t\t)\n\t\t" ;

				tempConstraints += "(=> ( <=" + "( - " + selLeft.toString() + " " + selRight.toString() + ") 0 )\n\t\t\t";

				tempConstraints += "( = " + selSetOp.toString() +  "0)\n\t\t)\n\t" ;

				tempConstraints += ")\n))";

				constraintString+=tempConstraints;

				
				constraintString += ConstraintGenerator.addCommentLine(" END XDATA CALC");

				break;
			default:
					break;
		}
		return constraintString;
	}

	public static String moreThanZeroTuple(GenerateCVC1 cvc) throws Exception 
	{
		String constraintString = "";
		String tempConstraints = "";
		String joinTable = cvc.setOpJoin;

		constraintString += ConstraintGenerator.addCommentLine(" BEGIN ATLEAST ONE TUPLE IN THE FINAL TABLE");

		tempConstraints = "(assert\n(or\n";

		for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		{
			Expr cntExpr = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , i+1);

			Expr cnEqCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExpr, ConstraintGenerator.ctx.mkInt(0));

			tempConstraints+="\t" + cnEqCheck.toString() + "\n";
		}

		tempConstraints += "\n))";

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END ATLEAST ONE TUPLE IN THE FINAL TABLE");

		return constraintString;

	}


	public static String moreThanOneTuple(GenerateCVC1 cvc) throws Exception 
	{
		String constraintString = "";
		String tempConstraints = "";
		String joinTable = cvc.setOpJoin;

		constraintString += ConstraintGenerator.addCommentLine(" BEGIN ATLEAST ONE TUPLE IN THE FINAL TABLE");

		tempConstraints = "(assert\n(or\n";

		for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
		{
			Expr cntExpr = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-1 , i+1);

			Expr cnEqCheck = ConstraintGenerator.ctx.mkGt((ArithExpr) cntExpr, ConstraintGenerator.ctx.mkInt(1));

			tempConstraints+="\t" + cnEqCheck.toString() + "\n";
		}

		tempConstraints += "\n))";

		constraintString += tempConstraints;

		constraintString += ConstraintGenerator.addCommentLine(" END ATLEAST ONE TUPLE IN THE FINAL TABLE");

		return constraintString;

	}
	public static String genConstraintsToKillSetOpMutants(GenerateCVC1 cvc) throws Exception 
	{
		String constraintString= "";
		String tempConstraints = "";
		String joinTable = cvc.setOpJoin;


		//all variations of union
		if(cvc.getqStructure().setOperator == "UNION")
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION ALL")) // union vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT")) // union vs intersect
			{
				constraintString += getXDATACNT(cvc,"UNION");

				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				tempConstraints="";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selRight = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selRightGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selRightGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================

			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT ALL")) //union vs intersect all
			{
				constraintString += getXDATACNT(cvc,"INTERSECT ALL");

				constraintString += moreThanOneTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")) //union vs except
			{
				constraintString += getXDATACNT(cvc,"UNION");

				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================


				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT ALL")) // union vs except all
			{
				constraintString += getXDATACNT(cvc,"UNION");

				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================

				
			}

		}

		//all variations of interesct
		else if(cvc.getqStructure().setOperator == "INTERSECT" && cvc.isAll==0)
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION ALL")) // intersect vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION")) // intersect vs union 
			{
				constraintString += getXDATACNT(cvc,"UNION");

				
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				tempConstraints="";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selRight = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selRightGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selRightGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT ALL")) // intersect vs intersect all
			{
				constraintString += getXDATACNT(cvc,"INTERSECT ALL");

				constraintString += moreThanOneTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")) //intersect vs except 
			{
				constraintString += getXDATACNT(cvc,"EXCEPT");

				constraintString += moreThanZeroTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT ALL")) // intersect vs except all
			{
				constraintString += getXDATACNT(cvc,"EXCEPT ALL");

				constraintString += moreThanZeroTuple(cvc);
			}

		}

		//all variations of except
		else if(cvc.getqStructure().setOperator == "EXCEPT" && cvc.isAll==0)
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION ALL")) //except vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanZeroTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION")) //except vs union 
			{
				constraintString += getXDATACNT(cvc,"UNION");

				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================

			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT ALL")) // except vs intersect all
			{
				constraintString += getXDATACNT(cvc,"INTERSECT ALL");

				constraintString += moreThanOneTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT")) //except vs intersect
			{
				constraintString += getXDATACNT(cvc,"EXCEPT");

				constraintString += moreThanZeroTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT ALL")) // except and except all
			{
				constraintString += getXDATACNT(cvc,cvc.getCurrentMutant().getMutationNode().toString());

				constraintString += moreThanOneTuple(cvc);
			}

		}

		//all variations of UNION ALL
		else if(cvc.getqStructure().setOperator == "UNION ALL")
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")) //union all vs except
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION")) // union vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);

			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT ALL")) // union all vs intersect all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");
				
				
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				tempConstraints="";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selRight = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selRightGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selRightGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT")) // union all vs intersect
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT ALL")) //union all vs except all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");
				
				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================
			}

		}

		//all variations of Intersect ALL
		else if(cvc.getqStructure().setOperator == "INTERSECT" && cvc.isAll==1)
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")) //intersect all vs except
			{
				constraintString += getXDATACNT(cvc,"INTERSECT ALL");

				constraintString += moreThanZeroTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION")) // intersect all vs union
			{
				constraintString += getXDATACNT(cvc,"INTERSECT ALL");

				constraintString += moreThanOneTuple(cvc);

			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION ALL")) // intersect all vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selLeftGt + ")\n";
				}
				constraintString+=tempConstraints;
				tempConstraints="";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selRight = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-3 , i+1);
					Expr selRightGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selRight, ConstraintGenerator.ctx.mkInt(0));
					tempConstraints+=selRightGt + ")\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n)";
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT")) // intersect all vs intersect
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");

				constraintString += moreThanOneTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT ALL")) //intersect all vs except all
			{
				constraintString += getXDATACNT(cvc,"EXCEPT ALL");

				constraintString += moreThanZeroTuple(cvc);
			}

		}

		//all variations of except all
		else if(cvc.getqStructure().setOperator == "EXCEPT" && cvc.isAll==1)
		{
			if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("EXCEPT")) //Except all vs except
			{
				constraintString += getXDATACNT(cvc,"EXCEPT ALL");

				constraintString += moreThanOneTuple(cvc);
				
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION")) // except all vs union
			{
				constraintString += getXDATACNT(cvc,"UNION");

				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================

			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("UNION ALL")) // except all vs union all
			{
				constraintString += getXDATACNT(cvc,"UNION ALL");
				
				//=========================================================================================================================
				tempConstraints+="(assert\n(or\n";
				for(int i=0 ; i<cvc.getNoOfOutputTuples(joinTable) ; i++)
				{
					Expr selLeft = ConstraintGenerator.genSelectTest(cvc, joinTable , cvc.getTableMap().getSQTableByName(joinTable).getNoOfColumn()-2 , i+1);
					Expr selLeftGt = ConstraintGenerator.ctx.mkEq((ArithExpr) selLeft, ConstraintGenerator.ctx.mkInt(1));
					tempConstraints+=selLeftGt.toString() + "\n";
				}
				constraintString+=tempConstraints;
				constraintString+="\n))";

				//=========================================================================================================================
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT")) // except all vs intersect
			{
				constraintString += getXDATACNT(cvc,"EXCEPT ALL");

				constraintString += moreThanZeroTuple(cvc);
			}
			else if(cvc.getCurrentMutant().getMutationNode().toString().equalsIgnoreCase("INTERSECT ALL")) //except all vs intersect all
			{
				constraintString += getXDATACNT(cvc,"EXCEPT ALL");

				constraintString += moreThanZeroTuple(cvc);
			}

		}
		
		return constraintString;
	}
	private static String addOuterQueryAsSubqueryConstraintsForSetOps(GenerateCVC1 cvc, QueryBlockDetails qbl, QueryBlockDetails qbr) throws Exception 
	{
		String constraintString = createSetOpHeader(cvc,qbl,qbr);

		String tempConstraints="";
		String joinTable = cvc.setOpJoin;

		if(cvc.getCurrentMutant()==null || (cvc.getCurrentMutant()!=null && !cvc.getTypeOfMutation().equalsIgnoreCase("DATASET TO KILL SET OPERATOR MUTATIONS ") ))
		{
			constraintString+= getXDATACNT(cvc);

			if(cvc.getTypeOfMutation().equalsIgnoreCase("DATASET FOR GENERATING NON EMPTY RESULT "))
			{
				constraintString += moreThanZeroTuple(cvc);
			}
		}
		else
		{
			constraintString+= genConstraintsToKillSetOpMutants(cvc);
		}
		
		
		
		
		
		return constraintString;

		
	}

	public static void getColumnsForMapping(GenerateCVC1 cvc) {

		if(cvc.regNo==0)
		{
			ArrayList<Node> projectedColNodes = cvc.getqStructure().lstProjectedCols;

			String tableName="JSQL0";	
			
			for(int i=0; i<2 ; i++)
			{
				if(i==1)
				{
					tableName="JSQR0";
				}
				for(Node x : projectedColNodes)
				{
					String getColName = tableName + "_" + x.getColumn().getTableName() + "__" +x.getColumn().getColumnName() + cvc.getTableMap().getTable(x.getColumn().getTableName().toUpperCase()).getColumnIndex(x.getColumn().getColumnName());
					Column corrColumn = cvc.getTableMap().getSQTables().get(tableName).getColumn(getColName);
					addToMap(cvc,tableName,corrColumn);
				}
				Column lastColumn = cvc.getTableMap().getSQTableByName(tableName).getLastColumnValue();
				addToMap(cvc, tableName, lastColumn);

		}

		}
		cvc.regNo=1;
		
	}

	/**
	 * This method is used to get constraints for outer clause subquery components
	 * 
	 * @author Sunanda
	 * @param qb
	 * @param cvc
	 * @return constraints
	 */
	private static String addOuterQueryAsSubqueryConstraints(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception {
		String constraintString = "";
		if (Configuration.outerSQ.equalsIgnoreCase("false")) { // outer query is not treated as SQ
			if (qb.level == 0) {
				// if(qb.isDistinct && !isAggregationPresentInQuery(qb)){

				// }
				// else
				if (qb.isDistinct && isAggregationPresentInQuery(qb)) {
					pushProjectedColumnsInGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());
				}
				if (qb.groupByNodes.size() != 0 || qb.getHavingClause() != null) {
					pushHavingClauseAttrInProjectedColumns(qb.getHavingClause(), qb.getProjectedCols());
					joinSubqueryConstraintsForFromClauseSubquery(cvc, qb, "outer");
					if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
						if (!cvc.subqueryConstraintsMap.get("outer").SQDefine.isEmpty()) {
							String constr = "";
							for (String key : cvc.subqueryConstraintsMap.get("outer").SQDefine.keySet()) {
								String joinTable = key;
								constr += cvc.subqueryConstraintsMap.get("outer").SQDefine.get(joinTable);
							}
							constraintString += constr;
						}

						constraintString += ConstraintGenerator
								.addCommentLine(
										"END OF CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

						constraintString += ConstraintGenerator
								.addCommentLine(" CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
						if (isAggregationPresentInQuery(qb)) {
							// if( qb.isConstrainedAggregation ) {

							// System.out.println("group by from clasue");
							if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
								constraintString += ConstraintGenerator
										.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc, qb, "outer");
							} else {
								constraintString += ConstraintGenerator
										.GetGroupByConstraintsForSubqueryTableWithCount(cvc, qb, "outer", "");

							}
						} else if (qb.isDistinct) {
							pushProjectedColumnsInGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());

							constraintString += ConstraintGenerator
									.GetDistinctClauseConstraintsForSubqueryTableWithCount(cvc, qb, "outer", "DSQ");
							removeProjectedColumnsFromGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());
						}

						constraintString += ConstraintGenerator.addCommentLine(
								"END OF CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

						constraintString += ConstraintGenerator
								.addCommentLine(" END OF HAVING CLAUSE SUBQUERY BLOCK ");

					}
				}
			}
		} else { // Outer level is treated as subquery hence having clause needs to be merged
			// FIXME needs more work this itself is not sufficient
			if (qb.level == 0) {
				if (qb.isDistinct && isAggregationPresentInQuery(qb)) {
					pushProjectedColumnsInGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());
				}
				if (qb.groupByNodes.size() != 0 || qb.getHavingClause() != null) {
					pushHavingClauseAttrInProjectedColumns(qb.getHavingClause(), qb.getProjectedCols());
				}
				joinSubqueryConstraintsForFromClauseSubquery(cvc, qb, "outer");
				if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
					if (!cvc.subqueryConstraintsMap.get("outer").SQDefine.isEmpty()) {
						String constr = "";
						for (String key : cvc.subqueryConstraintsMap.get("outer").SQDefine.keySet()) {
							String joinTable = key;
							if (joinTable.equalsIgnoreCase("JSQ0")) {
								// Vector<Node> correlationConds = cvc.tempJoinCorrelationConds.get(joinTable);

								constr += cvc.subqueryConstraintsMap.get("outer").SQDefine.get(joinTable);

								// constr +=
								// GenerateJoinPredicateConstraints.generateConstraintsForCorrelationAttributes(
								// cvc,
								// joinTable, correlationConds, qb.getLevel()) + "\n";
							}

						}
						constraintString += constr;
					}

					constraintString += ConstraintGenerator
							.addCommentLine("END OF CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

					constraintString += ConstraintGenerator
							.addCommentLine(" CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
					if (!qb.isDistinct && isAggregationPresentInQuery(qb)) {
						// if( qb.isConstrainedAggregation ) {

						// System.out.println("group by from clasue");
						if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
							constraintString += ConstraintGenerator
									.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc, qb, "outer");
						} else {
							constraintString += ConstraintGenerator
									.GetGroupByConstraintsForSubqueryTableWithCount(cvc, qb, "outer", "");

						}
					} else if (qb.isDistinct) {
						pushProjectedColumnsInGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());

						constraintString += ConstraintGenerator
								.GetDistinctClauseConstraintsForSubqueryTableWithCount(cvc, qb, "outer", "DSQ");

						removeProjectedColumnsFromGroupBy(qb.getProjectedCols(), qb.getGroupByNodes());

					}

					constraintString += ConstraintGenerator.addCommentLine(
							"END OF CONSTRAINTS FOR HAVING CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

					constraintString += ConstraintGenerator.addCommentLine(" END OF HAVING CLAUSE SUBQUERY BLOCK ");

				}

			}
		}

		return constraintString;
	}

	/**
	 * This method is used to get constraints for where clause subquery components
	 * 
	 * @author Sunanda
	 * @param qb
	 * @param cvc
	 * @return constraints
	 */
	private static String addWhereClauseSubqueryRelatedConstraints(GenerateCVC1 cvc, QueryBlockDetails qb)
			throws Exception {
		String constraintString = "";
		for (QueryBlockDetails qbt : qb.getWhereClauseSubQueries()) {
			if (qbt.isDistinct && isAggregationPresentInQuery(qbt)) {
				pushProjectedColumnsInGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());
			}

			if (cvc.subqueryConstraintsMap.size() > 0 &&cvc.subqueryConstraintsMap.containsKey("where")&& !cvc.subqueryConstraintsMap.get("where").SQDefine.isEmpty()) {
				String constr = "";
				for (String key : cvc.subqueryConstraintsMap.get("where").SQDefine.keySet()) {
					String joinTable = key;
					Vector<Node> correlationConds = cvc.subqueryConstraintsMap.get("where").SQJoinCorrelationConds
							.get(joinTable);
					constr += cvc.subqueryConstraintsMap.get("where").SQDefine.get(joinTable);// mapping
					// Correlation constraints
					if (Configuration.outerSQ.equalsIgnoreCase("false")) {
						constr += GenerateJoinPredicateConstraints.generateConstraintsForCorrelationAttributes(cvc,
								joinTable, correlationConds, qbt.getLevel()) + "\n";
					}

				}
				constraintString += constr;
				// code to erase - parismita todo
			}
			constraintString += ConstraintGenerator
					.addCommentLine("END OF CONSTRAINTS FOR WHERE CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

			// constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS FOR
			// WHERE CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
			if (!qbt.isDistinct && isAggregationPresentInQuery(qbt)) {
				// System.out.println("group by from clasue");
				if (qbt.getHavingClause() != null) {
					pushHavingClauseAttrInProjectedColumns(qbt.getHavingClause(), qbt.getProjectedCols());
				}
				for (Node n : cvc.correlationHashMap.keySet()) {
					Node k = cvc.correlationHashMap.get(n).getCondition();
					if (n.getLevel() == qbt.getLevel()) {
						if (cvc.correlationHashMap.get(n).getOriginalLevelLeft() == qbt.getLevel())
							pushGrpbyAttrInProjectedColumns(k.getLeft(), qbt);
						if (cvc.correlationHashMap.get(n).getOriginalLevelRight() == qbt.getLevel())
							pushGrpbyAttrInProjectedColumns(k.getRight(), qbt);
						// pushProjectedColumnsInGroupBy(n, qbt.getGroupByNodes());
					}
				}
				if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
					constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc,
							qbt, "where");
				} else {
					constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithCount(cvc, qbt,
							"where", "");
				}
			} else if (qbt.isDistinct) {
				pushProjectedColumnsInGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());

				constraintString += ConstraintGenerator
						.GetDistinctClauseConstraintsForSubqueryTableWithCount(cvc, qbt, "where", "DSQ");
				removeProjectedColumnsFromGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());
			}
			// constraintString += ConstraintGenerator.addCommentLine("END OF CONSTRAINTS
			// FOR WHERE CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

			constraintString += ConstraintGenerator.addCommentLine(" END OF WHERE CLAUSE SUBQUERY BLOCK ");

		}
		return constraintString;
	}

	/**
	 * This method is used to get constraints for from clause subquery components
	 * 
	 * @author Sunanda
	 * @param qb
	 * @param cvc
	 * @return constraints
	 */
	private static String addFromClauseSubqueryRelatedConstraints(GenerateCVC1 cvc, QueryBlockDetails qb)
			throws Exception {
		String constraintString = "";
		for (QueryBlockDetails qbt : qb.getFromClauseSubQueries()) {

			// Handle Distinct Clause Attributes
			if (qbt.isDistinct && isAggregationPresentInQuery(qbt)) {
				pushProjectedColumnsInGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());
			}
			// constraintString += ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY
			// BLOCK ");

			constraintString += ConstraintGenerator
					.addCommentLine(" CONSTRAINTS FOR FROM CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

			// if(! qbt.getConjunctsQs().isEmpty()) {

			joinSubqueryConstraintsForFromClauseSubquery(cvc, qbt, "from"); // function which processes joins

			if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
				if (!cvc.subqueryConstraintsMap.get("from").SQDefine.isEmpty()) {
					String constr = "";
					for (String key : cvc.subqueryConstraintsMap.get("from").SQDefine.keySet()) {
						constr += cvc.subqueryConstraintsMap.get("from").SQDefine.get(key);
					}
					constraintString += constr;
				}

			}
			// }
			constraintString += ConstraintGenerator
					.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

			constraintString += ConstraintGenerator
					.addCommentLine(" CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
			if (!qbt.isDistinct && isAggregationPresentInQuery(qbt)) {
				// System.out.println("group by from clasue");
				if (qbt.getHavingClause() != null) {
					pushHavingClauseAttrInProjectedColumns(qbt.getHavingClause(), qbt.getProjectedCols());
				}
				if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
					constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc,
							qbt, "from");
				} else {
					constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithCount(cvc, qbt,
							"from", "");

				}
			} else if (qbt.isDistinct) {
				pushProjectedColumnsInGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());

				constraintString += ConstraintGenerator
						.GetDistinctClauseConstraintsForSubqueryTableWithCount(cvc, qbt, "from", "DSQ");
				removeProjectedColumnsFromGroupBy(qbt.getProjectedCols(), qbt.getGroupByNodes());
			}

			constraintString += ConstraintGenerator
					.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

			// constraintString += getConstraintsForQueryBlock(cvc, qbt);
			constraintString += ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY BLOCK ");
		}

		return constraintString;
	}

	private static void pushProjectedColumnsInGroupBy(ArrayList<Node> projectedCols, ArrayList<Node> groupByNodes) {
		for (Node n : projectedCols) {
			if (n.getType().equalsIgnoreCase(n.getColRefType())) {
				if (groupByNodes.contains(n))
					continue;
				groupByNodes.add(n);
			}

		}
	}

	private static void removeProjectedColumnsFromGroupBy(ArrayList<Node> projectedCols, ArrayList<Node> groupByNodes) {
		for (Node n : projectedCols) {
			if (groupByNodes.contains(n))
				groupByNodes.remove(n);
		}
	}

	// private static void pushProjectedColumnsInGroupBy(Node n, ArrayList<Node>
	// groupByNodes) {
	// if (n == null || groupByNodes.contains(n))
	// return;
	// pushProjectedColumnsInGroupBy(n.getLeft(), groupByNodes);
	// pushProjectedColumnsInGroupBy(n.getRight(), groupByNodes);

	// if (n.getType() == "COLREF")
	// groupByNodes.add(n);
	// }

	public static Boolean isAggregationPresentInQuery(QueryBlockDetails qbt) {

		if (qbt.groupByNodes.size() != 0)
			return true;
		for (Node prjColumn : qbt.getProjectedCols()) {
			if (prjColumn.getType().equalsIgnoreCase("AGGREGATE NODE") && !prjColumn.fromBelowLevelFClauseSQ
					&& qbt.getBaseRelations().contains(prjColumn.getTableAlias()!=null&&!prjColumn.getTableAlias().equalsIgnoreCase("")?prjColumn.getTableAlias().toUpperCase():prjColumn.getTableNameNo().toUpperCase()))
				return true;
		}
		return false;
	}

	// parismita
	public static Boolean isAggregationPresentInQuery(QueryStructure qbt) {

		if (qbt.lstGroupByNodes.size() != 0)
			return true;
		for (Node prjColumn : qbt.lstProjectedCols) {
			if (prjColumn.getType().equalsIgnoreCase("AGGREGATE NODE"))
				return true;
		}
		return false;
	}

	public static void pushHavingClauseAttrInProjectedColumns(Node n, ArrayList<Node> projectedCols) {
		// TODO Auto-generated method stub

		if (n == null || n.getType() == null || n.getType().equalsIgnoreCase("VALUE"))
			return;
		pushHavingClauseAttrInProjectedColumns(n.getLeft(), projectedCols);
		pushHavingClauseAttrInProjectedColumns(n.getRight(), projectedCols);

		if (n.getLeft() == null && n.getRight() == null && !projectedCols.contains(n))
			projectedCols.add(n);

	}

	private static void pushGrpbyAttrInProjectedColumns(Node n, QueryBlockDetails qbt) {
		if (n == null || n.getType() == null)
			return;
		pushGrpbyAttrInProjectedColumns(n.getLeft(), qbt);
		pushGrpbyAttrInProjectedColumns(n.getRight(), qbt);

		if (n.getType() == "COLREF" && !qbt.getProjectedCols().contains(n)) {
			qbt.getProjectedCols().add(n);
		}
		if (n.getType() == "COLREF" && !qbt.getGroupByNodes().contains(n)) {
			qbt.getGroupByNodes().add(n);
		}
	}

	// *************************************Sunanda Test Code for joins
	// start************************************

	public static void joinSubqueryConstraintsForFromClauseSubquery(GenerateCVC1 cvc, QueryBlockDetails queryBlock,
			String subqueryType) throws Exception {

		// if(queryBlock != null)
		// {
		// System.out.println("From Clause");
		// }

		String constraintString = "";
		ConstraintGenerator constrGen = new ConstraintGenerator();

		/** get the index of this where clause subquery */
		// int index = UtilsRelatedToNode.getQueryIndexOfSubQNode(subQ);

		/** Used to store conditions of this subquery block */
		Vector<Node> condsInSubQ = new Vector<Node>();

		/** Get the query block of this subquery node */
		QueryBlockDetails subQuery = queryBlock;

		// ********************Getting all the conditions together
		// starts**************************************

		if (subQuery != null) {
			/** Get the conditions of the subquery */
			/** FIXME: What should be done if inside is ORing of conditions */
			for (ConjunctQueryStructure con : subQuery.getConjunctsQs()) {
				condsInSubQ.addAll(con.getStringSelectionConds());
				condsInSubQ.addAll(con.getSelectionConds());
				/** add equi joins */
				for (Vector<Node> ecn : con.getEquivalenceClasses()) {
					Node n1 = ecn.get(0);
					for (int l = 1; l < ecn.size(); l++) {
						Node jn = new Node();
						jn.setLeft(n1);
						jn.setRight(ecn.get(l));
						jn.setOperator("=");
						// jn.setQueryIndex();
						condsInSubQ.add(jn);
					}
				}
				// condsInSubQ.addAll(con.getJoinConds());
				condsInSubQ.addAll(con.getAllConds());
			}
		}

		// //nesting for the future - parismita
		// for (ConjunctQueryStructure conjunct : queryBlock.getConjunctsQs()) {
		// if(conjunct.getAllSubQueryConds() != null){
		// for(int i=0; i < conjunct.getAllSubQueryConds().size(); i++){
		// Node subQ = conjunct.getAllSubQueryConds().get(i);
		// }

		// ***************************Getting all the conditions together ends
		// ****************************

		if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
			/**
			 * if subQuery contains a JOIN then all the selection and correlations
			 * conditions from the subquery are enforced on the tempJoin table
			 **/
			if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
				constraintString += GenerateJoinPredicateConstraints.getConstraintsForJoinsWithoutCount(cvc, subQuery,
						null, null, "=", true, subqueryType);
			} else {
				constraintString += GenerateJoinPredicateConstraints.getConstraintsForJoinsInSameQueryBlockWithCount(
						cvc, subQuery, null, null, "=", true, subqueryType);
			}
		} else {
			for (int i = 0; i < condsInSubQ.size(); i++) {

				Node n = condsInSubQ.get(i);
				if (n.getLeft().getType().equals(Node.getColRefType())
						&& n.getRight().getType().equals(Node.getColRefType()) && n.getOperator().equals("="))
					constraintString += GenerateJoinPredicateConstraints.getConstraintsForEquiJoins(cvc, subQuery,
							n.getLeft(), n.getRight(), subqueryType); /** If it is equi join condition */
				// passed from by sunanda

				else if (n.getLeft().getType().equalsIgnoreCase(Node.getColRefType())
						&& n.getRight().getType().equalsIgnoreCase(Node.getColRefType())
						&& !n.getOperator().equalsIgnoreCase("")) /** if non equi join constraint */

					constraintString += GenerateJoinPredicateConstraints.getConstraintsForNonEquiJoins(cvc, subQuery,
							n.getLeft(), n.getRight(), n.getOperator(), subqueryType);

				else {
					String tableNameNo = n.getLeft().getTableNameNo();
					int offset = cvc.getRepeatedRelNextTuplePos().get(tableNameNo)[1];

					/** The total number of tuples across all groups of this subquery */
					int num = cvc.getNoOfTuples().get(tableNameNo) * subQuery.getNoOfGroups();
					for (int j = 0; j < num; j++) {
						if (UtilsRelatedToNode.isStringSelection(n, 0)) {/** If it is a string selection condition */

							String subQueryConstraints = constrGen.genPositiveCondsForPred(subQuery, n, j + offset);
							String result = cvc.getStringSolver()
									.solveConstraints(subQueryConstraints, cvc.getResultsetColumns(), cvc.getTableMap())
									.get(0);
							constraintString += result;
						} else {
							String res = ConstraintGenerator.genPositiveCondsForPred(subQuery, n, offset + j);
							constraintString += constrGen.getAssertConstraint(res);
						}
					}
				}
			}
		}
		// System.out.println(cvc.getCVCStr());
		//return constraintString;

	}

	//kumaran
	public static String joinSubqueryConstraintsForFromClauseSubqueryForSet(GenerateCVC1 cvc, QueryBlockDetails queryBlock,
			String subqueryType) throws Exception {

		// if(queryBlock != null)
		// {
		// System.out.println("From Clause");
		// }

		String constraintString = "";
		ConstraintGenerator constrGen = new ConstraintGenerator();

		/** get the index of this where clause subquery */
		// int index = UtilsRelatedToNode.getQueryIndexOfSubQNode(subQ);

		/** Used to store conditions of this subquery block */
		Vector<Node> condsInSubQ = new Vector<Node>();

		/** Get the query block of this subquery node */
		QueryBlockDetails subQuery = queryBlock;

		// ********************Getting all the conditions together
		// starts**************************************

		if (subQuery != null) {
			/** Get the conditions of the subquery */
			/** FIXME: What should be done if inside is ORing of conditions */
			for (ConjunctQueryStructure con : subQuery.getConjunctsQs()) {
				condsInSubQ.addAll(con.getStringSelectionConds());
				condsInSubQ.addAll(con.getSelectionConds());
				/** add equi joins */
				for (Vector<Node> ecn : con.getEquivalenceClasses()) {
					Node n1 = ecn.get(0);
					for (int l = 1; l < ecn.size(); l++) {
						Node jn = new Node();
						jn.setLeft(n1);
						jn.setRight(ecn.get(l));
						jn.setOperator("=");
						// jn.setQueryIndex();
						condsInSubQ.add(jn);
					}
				}
				// condsInSubQ.addAll(con.getJoinConds());
				condsInSubQ.addAll(con.getAllConds());
			}
		}

		// //nesting for the future - parismita
		// for (ConjunctQueryStructure conjunct : queryBlock.getConjunctsQs()) {
		// if(conjunct.getAllSubQueryConds() != null){
		// for(int i=0; i < conjunct.getAllSubQueryConds().size(); i++){
		// Node subQ = conjunct.getAllSubQueryConds().get(i);
		// }

		// ***************************Getting all the conditions together ends
		// ****************************

		if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
			/**
			 * if subQuery contains a JOIN then all the selection and correlations
			 * conditions from the subquery are enforced on the tempJoin table
			 **/
			if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
				constraintString += GenerateJoinPredicateConstraints.getConstraintsForJoinsWithoutCount(cvc, subQuery,
						null, null, "=", true, subqueryType);
			} else {
				constraintString += GenerateJoinPredicateConstraints.getConstraintsForJoinsInSameQueryBlockWithCount(
						cvc, subQuery, null, null, "=", true, subqueryType);
			}
		} else {
			for (int i = 0; i < condsInSubQ.size(); i++) {

				Node n = condsInSubQ.get(i);
				if (n.getLeft().getType().equals(Node.getColRefType())
						&& n.getRight().getType().equals(Node.getColRefType()) && n.getOperator().equals("="))
					constraintString += GenerateJoinPredicateConstraints.getConstraintsForEquiJoins(cvc, subQuery,
							n.getLeft(), n.getRight(), subqueryType); /** If it is equi join condition */
				// passed from by sunanda

				else if (n.getLeft().getType().equalsIgnoreCase(Node.getColRefType())
						&& n.getRight().getType().equalsIgnoreCase(Node.getColRefType())
						&& !n.getOperator().equalsIgnoreCase("")) /** if non equi join constraint */

					constraintString += GenerateJoinPredicateConstraints.getConstraintsForNonEquiJoins(cvc, subQuery,
							n.getLeft(), n.getRight(), n.getOperator(), subqueryType);

				else {
					String tableNameNo = n.getLeft().getTableNameNo();
					int offset = cvc.getRepeatedRelNextTuplePos().get(tableNameNo)[1];

					/** The total number of tuples across all groups of this subquery */
					int num = cvc.getNoOfTuples().get(tableNameNo) * subQuery.getNoOfGroups();
					for (int j = 0; j < num; j++) {
						if (UtilsRelatedToNode.isStringSelection(n, 0)) {/** If it is a string selection condition */

							String subQueryConstraints = constrGen.genPositiveCondsForPred(subQuery, n, j + offset);
							String result = cvc.getStringSolver()
									.solveConstraints(subQueryConstraints, cvc.getResultsetColumns(), cvc.getTableMap())
									.get(0);
							constraintString += result;
						} else {
							String res = ConstraintGenerator.genPositiveCondsForPred(subQuery, n, offset + j);
							constraintString += constrGen.getAssertConstraint(res);
						}
					}
				}
			}
		}
		// System.out.println(cvc.getCVCStr());
		return constraintString;

	}

	// *************************************Sunanda Test Code
	// end************************************

	/**
	 * This method is used to get constraints for all the conditions involved in
	 * this query block, including from clause sub query blocks, if any
	 * 
	 * @param qb
	 * @param cvc
	 */
	public static String getConstraintsForQueryBlockSMT(GenerateCVC1 cvc) throws Exception {

		String constraintString = "";
		QueryBlockDetails qb = cvc.getOuterBlock();
		try {
			constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF THIS BLOCK ");
			// constraintString += getConstraintsForQueryBlockExceptSubQuriesSMT(cvc, qb);
			constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF THIS BLOCK ");

			/** Add constraints related to From clause subqueries block */
			for (QueryBlockDetails qbt : qb.getFromClauseSubQueries()) {

				constraintString += "\n%---------------------------------\n% FROM CLAUSE SUBQUERY BLOCK\n%---------------------------------\n";
				// constraintString += getConstraintsForQueryBlockSMT(cvc, qbt);
				constraintString += "\n%---------------------------------\n% END OF FROM CLAUSE SUBQUERY BLOCK\n%---------------------------------\n";
			}
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}

		return constraintString;

	}

	/**
	 * This method is used to get constraints for all the conditions involved in
	 * this query block, including from clause sub query blocks, if any
	 * 
	 * @param qb
	 * @param cvc
	 */
	public static String getConstraintsForQueryBlock(GenerateCVC1 cvc, QueryBlockDetails qb, Node n) throws Exception {

		String constraintString = "";
		try {
			/* Constraints for having clause */
			if (qb.getHavingClause() != null) {
				pushHavingClauseAttrInProjectedColumns(qb.getHavingClause(), qb.getProjectedCols());
				// joinSubqueryConstraintsForFromClauseSubquery(cvc, qb, "outer");
				if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
					if (!cvc.subqueryConstraintsMap.get("where").SQDefine.isEmpty()) {
						String constr = "";
						for (String key : cvc.subqueryConstraintsMap.get("where").SQDefine.keySet()) {
							constr += cvc.subqueryConstraintsMap.get("where").SQDefine.get(key);
						}
						constraintString += constr;
					}

					constraintString += ConstraintGenerator
							.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

					constraintString += ConstraintGenerator
							.addCommentLine(" CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
					if (qb.groupByNodes.size() != 0) {
						// System.out.println("group by from clasue");
						if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
							constraintString += ConstraintGenerator
									.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc, qb, "outer");
						} else {
							constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithCount(cvc,
									qb, "outer", "");

						}
					}

					constraintString += ConstraintGenerator
							.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

					constraintString += ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY BLOCK ");

				}

			}

			for (QueryBlockDetails qbt : qb.getFromClauseSubQueries()) {

				constraintString += ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY BLOCK ");

				constraintString += ConstraintGenerator
						.addCommentLine(" CONSTRAINTS FOR FROM CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");
				if (!qbt.getConjunctsQs().isEmpty()) {

					// joinSubqueryConstraintsForFromClauseSubquery(cvc, qbt, "from"); // function
					// which processes joins

					if (Configuration.getProperty("tempJoins").equalsIgnoreCase("true")) {
						if (!cvc.subqueryConstraintsMap.get("from").SQDefine.isEmpty()) {
							String constr = "";
							for (String key : cvc.subqueryConstraintsMap.get("from").SQDefine.keySet()) {
								constr += cvc.subqueryConstraintsMap.get("from").SQDefine.get(key);
							}
							constraintString += constr;
						}

						// ***************************test code
						// sunanda*************************************

						// ************** TEST CODE END ******************//
					}
				}
				constraintString += ConstraintGenerator
						.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

				constraintString += ConstraintGenerator
						.addCommentLine(" CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");
				if (qbt.groupByNodes.size() != 0) {
					// System.out.println("group by from clasue");
					if (Configuration.getProperty("cntFlag").equalsIgnoreCase("false")) {
						constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithoutCount(cvc,
								qbt, "from");
					} else {
						constraintString += ConstraintGenerator.GetGroupByConstraintsForSubqueryTableWithCount(cvc, qbt,
								"from", "");

					}
				}

				constraintString += ConstraintGenerator
						.addCommentLine("END OF CONSTRAINTS FOR FROM CLAUSE SUBQUERY: GROUPBY SUBQUERY TABLE ");

				// constraintString += getConstraintsForQueryBlock(cvc, qbt);
				constraintString += ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY BLOCK ");
			}

			constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF THIS BLOCK ");
			constraintString += getConstraintsForQueryBlockExceptSubQuries(cvc, qb, n);

			constraintString += ConstraintGenerator.addCommentLine(" WHERE CLAUSE SUBQUERY BLOCK ");

			constraintString += ConstraintGenerator
					.addCommentLine(" CONSTRAINTS FOR WHERE CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

			// for(QueryBlockDetails qbt: qb.getWhereClauseSubQueries()){
			if (!cvc.subqueryConstraintsMap.get("where").SQDefine.isEmpty()) {
				String constr = "";
				for (String key : cvc.subqueryConstraintsMap.get("where").SQDefine.keySet()) {
					String joinTable = key;
					Vector<Node> correlationConds = cvc.subqueryConstraintsMap.get("where").SQJoinCorrelationConds
							.get(joinTable);
					constr += cvc.subqueryConstraintsMap.get("where").SQDefine.get(joinTable);

					constr += GenerateJoinPredicateConstraints.generateConstraintsForCorrelationAttributes(cvc,
							joinTable, correlationConds, qb.getLevel()) + "\n";
				}
				constraintString += constr;
			}
			// }
			constraintString += ConstraintGenerator
					.addCommentLine("END OF CONSTRAINTS FOR WHERE CLAUSE SUBQUERY: JOIN SUBQUERY TABLE ");

			constraintString += ConstraintGenerator.addCommentLine(" END OF WHERE CLAUSE SUBQUERY BLOCK ");

			constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF THIS BLOCK ");

		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}

		return constraintString;

	}

	/**
	 * This method is used to get constraints for all the conditions involved in
	 * this query block, including from clause sub query blocks, if any
	 * 
	 * @param qb
	 * @param cvc
	 */
	public static String getConstraintsForQueryBlockSMT(GenerateCVC1 cvc, Node n) throws Exception {

		String constraintString = "";
		QueryBlockDetails qb = cvc.getOuterBlock();
		try {
			constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS OF THIS BLOCK ");
			// constraintString += getConstraintsForQueryBlockExceptSubQuriesSMT(cvc, qb,
			// n);
			constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS OF THIS BLOCK ");

			/** Add constraints related to From clause subqueries block */
			for (QueryBlockDetails qbt : qb.getFromClauseSubQueries()) {

				constraintString += ConstraintGenerator.addCommentLine(" FROM CLAUSE SUBQUERY BLOCK ");
				// constraintString += getConstraintsForQueryBlockSMT(cvc, qbt);
				constraintString += ConstraintGenerator.addCommentLine(" END OF FROM CLAUSE SUBQUERY BLOCK ");
			}
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}

		return constraintString;

	}

	/**
	 * This method is used to get constraints for all the conditions of this query
	 * block
	 * 
	 * @param cvc
	 * @param qb
	 * @return
	 */
	public static String getConstraintsForQueryBlockExceptSubQuries(GenerateCVC1 cvc, QueryBlockDetails qb)
			throws Exception {
		String constraintString = "";
		Constraints constraints = new Constraints();
		// constraints.constraints.add("");
		// constraints.stringConstraints.add("");
		try {
			/** Add the positive conditions for each conjunct of this query block */
			for (ConjunctQueryStructure conjunct : qb.getConjunctsQs()) {

				if (qb.getLevel() == 0 && Configuration.outerSQ.equalsIgnoreCase("false")) // only for outer query
					constraintString += GenerateJoinPredicateConstraints.getConstraintsforEquivalenceClasses(cvc, qb,
							conjunct);

				constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS FOR THIS CONJUNCT ");
				// constraintString +=
				// GenerateConstraintsForConjunct.getConstraintsForConjuct(cvc, qb, conjunct);
				// constraints = Constraints.orConstraints(constraints,
				// GenerateConstraintsForConjunct.getConstraintsInConjuct(cvc, qb, conjunct));

				/**
				 * FIXME: Handle OR + Where clause Sub query Correctly
				 * Right Now we assume that if there is Where sub query then no ORing of conds
				 * Use Amol generalized approach
				 */
				constraintString += ConstraintGenerator.addCommentLine(" WHERE CLAUSE SUBQUERY BLOCK CONSTRAINTS ");
				constraintString += GenerateConstraintsForWhereClauseSubQueryBlock
						.getConstraintsForWhereClauseSubQueryBlock(cvc, qb, conjunct);
				constraintString += ConstraintGenerator
						.addCommentLine(" END OF WHERE CLAUSE SUBQUERY BLOCK CONSTRAINTS ");

				// constraintString += ConstraintGenerator.addCommentLine("END OF CONSTRAINTS
				// FOR THIS CONJUNCT ");
			}
			if (qb.getLevel() == 0 && Configuration.outerSQ.equalsIgnoreCase("false")) // only for outer query -
																						// parismita
			{
				constraintString += Constraints.getConstraint(cvc, constraints);

				Vector<String> strConstraints = new Vector<String>();
				strConstraints.addAll(constraints.stringConstraints);
				// System.out.println(constraints.constraints);
				Vector<String> solvedStringConstraint = cvc.getStringSolver().solveConstraints(strConstraints,
						cvc.getResultsetColumns(), cvc.getTableMap(), true);
				for (String str : solvedStringConstraint) {
					constraintString += str + "\n";
				}
			}
			// constraintString += getCaseConditionConstraints(cvc);
			// constraintString += getGroupByAndHavingClauseConstraints(cvc, qb);

			constraintString += getOtherConstraintsForQueryBlock(cvc, qb);
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * This method is used to get constraints for all the conditions of this query
	 * block
	 * 
	 * @param cvc
	 * @param qb
	 * @return
	 */
	public static String getConstraintsForQueryBlockExceptSubQuries(GenerateCVC1 cvc, QueryBlockDetails qb, Node n)
			throws Exception {
		String constraintString = "";
		Constraints constraints = new Constraints();
		constraints.constraints.add("");
		constraints.stringConstraints.add("");
		try {
			/** Add the positive conditions for each conjunct of this query block */
			for (ConjunctQueryStructure conjunct : qb.getConjunctsQs()) {
				constraintString += ConstraintGenerator.addCommentLine(" CONSTRAINTS FOR THIS CONJUNCT ");
				// constraintString +=
				// GenerateConstraintsForConjunct.getConstraintsForConjuct(cvc, qb, conjunct);
				constraints = Constraints.orConstraints(constraints,
						GenerateConstraintsForConjunct.getConstraintsInConjuct(cvc, qb, conjunct));

				/**
				 * FIXME: Handle OR + Where clause Sub query Correctly
				 * Right Now we assume that if there is Where sub query then no ORing of conds
				 * Use Amol generalized approach
				 */
				constraintString += ConstraintGenerator.addCommentLine(" WHERE CLAUSE SUBQUERY BLOCK CONSTRAINTS ");
				constraintString += GenerateConstraintsForWhereClauseSubQueryBlock
						.getConstraintsForWhereClauseSubQueryBlock(cvc, qb, conjunct);
				constraintString += ConstraintGenerator
						.addCommentLine(" END OF WHERE CLAUSE SUBQUERY BLOCK CONSTRAINTS ");

				// constraintString += ConstraintGenerator.addCommentLine(" END OF CONSTRAINTS
				// FOR THIS CONJUNCT\n");

			}
			// FOR CASE CONDITION IN WHERE CLAUSE - ADD CONSTRAINTS APPENDING AND HERE

			constraintString += Constraints.getConstraint(cvc, constraints);
			// String stringConstraints= Constraints.getStringConstraints(cvc,constraints);
			// cvc.getStringConstraints().add(stringConstraints);
			ArrayList<String> strConstraints = Constraints.getStringConstraints(cvc, constraints);
			for (String constraint : strConstraints) {
				cvc.getStringConstraints().add(constraint.toString());
			}

			// constraintString += getCaseConditionConstraints(cvc);
			constraintString += getGroupByClauseConstraints(cvc, qb, n);

			constraintString += getOtherConstraintsForQueryBlock(cvc, qb);
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * Used to get app constraints, parameter constraints and unique key constraints
	 * for the given query block
	 * 
	 * @param cvc
	 * @param qb
	 * @return
	 */
	public static String getOtherConstraintsForQueryBlock(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception {

		String constraintString = "";
		try {
			/** Add constraints related to parameters in the query block */
			constraintString += ConstraintGenerator.addCommentLine("PARAMETERIZED CLAUSE CONSTRAINTS ");
			constraintString += RelatedToParameters.getConstraintsForParameters(cvc, qb);
			constraintString += ConstraintGenerator.addCommentLine("END OF PARAMETERIZED CLAUSE CONSTRAINTS ");

			/** Application constraints if any */
			constraintString += ConstraintGenerator.addCommentLine("APPLICATION CONSTRAINTS ");
			/* FIXME: constraintString += NonEmptyConstraints; */
			constraintString += ConstraintGenerator.addCommentLine("END OF APPLICATION CONSTRAINTS ");

			constraintString += ConstraintGenerator.addCommentLine(" UNIQUE  KEY CONSTRAINTS ");
			constraintString += GenerateUniqueKeyConstraints.generateUniqueConstraints(cvc, qb, qb.getUniqueElements());
			constraintString += ConstraintGenerator.addCommentLine("END OF UNIQUE  KEY CONSTRAINTS ");
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * Used to get group by and having clause constraints for the given query block
	 * 
	 * @param cvc
	 * @param qb
	 * @return
	 * @throws Exception
	 */
	public static String getGroupByAndHavingClauseConstraints(GenerateCVC1 cvc, QueryBlockDetails qb) throws Exception {

		String constraintString = "";
		try {
			/** get group by constraints */
			constraintString += ConstraintGenerator.addCommentLine("GROUP BY CLAUSE CONSTRAINTS");
			constraintString += GenerateGroupByConstraints.getGroupByConstraints(cvc, qb);
			constraintString += ConstraintGenerator.addCommentLine("END OF GROUP BY CLAUSE CONSTRAINTS");

			// commented by Sunanda for having
			// /** Generate havingClause constraints */
			// constraintString += ConstraintGenerator.addCommentLine("HAVING CLAUSE
			// CONSTRAINTS");
			// for(int k=0; k < qb.getAggConstraints().size();k++)
			// {
			// constraintString +=
			// GenerateConstraintsForHavingClause.getMinSumMaxVariableDeclaration(cvc, qb,
			// qb.getAggConstraints().get(k));
			//
			// for(int j=0; j< qb.getNoOfGroups();j ++)
			// {
			// constraintString +=
			// GenerateConstraintsForHavingClause.getHavingClauseConstraints(cvc, qb,
			// qb.getAggConstraints().get(k), qb.getFinalCount(), j);
			// }
			// }
			// constraintString += ConstraintGenerator.addCommentLine("END OF HAVING CLAUSE
			// CONSTRAINTS");
		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * Used to get group by and having clause constraints for the given query block
	 * 
	 * @param cvc
	 * @param qb
	 * @return
	 * @throws Exception
	 */
	public static String getGroupByClauseConstraints(GenerateCVC1 cvc, QueryBlockDetails qb, Node n) throws Exception {

		String constraintString = "";
		try {
			/** get group by constraints */
			constraintString += ConstraintGenerator.addCommentLine("GROUP BY CLAUSE CONSTRAINTS");
			constraintString += GenerateGroupByConstraints.getGroupByConstraints(cvc, qb, n);
			constraintString += ConstraintGenerator.addCommentLine("END OF GROUP BY CLAUSE CONSTRAINTS");

		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * This method generated the constraint string for the case conditions specified
	 * in projected columns or where clauses
	 * 
	 * @param cvc
	 * @return
	 * @throws Exception
	 */
	public static String getCaseConditionConstraints(GenerateCVC1 cvc) throws Exception {
		String constraintString = "";

		try {

			constraintString += ConstraintGenerator.addCommentLine("CASE CONDITION CONSTRAINTS");
			constraintString += GenerateConstraintsForCaseConditions.getCaseConditionConstraintsForOriginalQuery(cvc,
					cvc.getOuterBlock());
			constraintString += ConstraintGenerator.addCommentLine("END OF CASE CONDITION CONSTRAINTS");

		} catch (Exception e) {
			logger.log(Level.SEVERE, e.getMessage(), e);
			throw e;
		}
		return constraintString;
	}

	/**
	 * Get list of from tables in this query block, in the form of table name and
	 * its occurrence
	 * 
	 * @param cvc
	 * @param qbt
	 * @return
	 */
	public static HashMap<String, Table> getListOfTablesInQueryBlock(GenerateCVC1 cvc, QueryBlockDetails qbt) {

		/** stores list of tables in this query block */
		HashMap<String, Table> tables = new HashMap<String, Table>();

		/** Get the list of tables in this query block */
		for (String relation : qbt.getBaseRelations()) {

			/** Get base table name for this relation */
			String tableName = relation.substring(0, relation.length() - 1);
			/** FIXME: If the relation occurrence >= 10 then problem */

			/** Get the table details from base table */
			for (int i = 0; i < cvc.getResultsetTables().size(); i++) {

				Table table1 = cvc.getResultsetTables().get(i);

				if (table1.getTableName().equalsIgnoreCase(tableName)) {/** The data base relation is found */

					/** If this table is not already added */
					if (!tables.containsKey(table1))
						tables.put(relation, table1);
					break;
				}
			}
		}

		return tables;
	}

	/** Below are the setters and getters for the variables of this class */
	public ArrayList<Node> getProjectedCols() {
		return projectedCols;
	}

	public void setProjectedCols(ArrayList<Node> projectedCols) {
		this.projectedCols = projectedCols;
	}

	public ArrayList<AggregateFunction> getAggFunc() {
		return aggFunc;
	}

	public void setAggFunc(ArrayList<AggregateFunction> aggFunc) {
		this.aggFunc = aggFunc;
	}

	/*
	 * public ArrayList<Conjunct> getConjuncts() {
	 * return conjuncts;
	 * }
	 * 
	 * public void setConjuncts(ArrayList<Conjunct> conjuncts) {
	 * this.conjuncts = conjuncts;
	 * }
	 */

	public ArrayList<ConjunctQueryStructure> getConjunctsQs() {
		return conjunctsqs;
	}

	public void setConjunctsQs(ArrayList<ConjunctQueryStructure> conjuncts) {
		this.conjunctsqs = conjuncts;
	}

	public void addConjunctsQs(Vector<ConjunctQueryStructure> conjuncts)
	{
		this.conjunctsqs.addAll(conjuncts);
	}

	public int getLevel() {
		return level;
	}

	public void setLevel(int i) {
		this.level = i;
	}

	public int getLimit() {
		return limit;
	}

	public void setLimit(int i) {
		this.limit = i;
	}

	public ArrayList<Node> getGroupByNodes() {
		return groupByNodes;
	}

	public void setGroupByNodes(ArrayList<Node> groupByNodes) {
		this.groupByNodes = groupByNodes;
	}

	public ArrayList<Node> getOrderByNodes() {
		return orderByNodes;
	}

	public void setOrderByNodes(ArrayList<Node> orderByNodes) {
		this.orderByNodes = orderByNodes;
	}

	public boolean isConstrainedAggregation() {
		return isConstrainedAggregation;
	}

	public void setConstrainedAggregation(boolean isConstrainedAggregation) {
		this.isConstrainedAggregation = isConstrainedAggregation;
	}

	// code added by sunanda for distinct
	public void setDistinct(boolean isDistinct) {
		this.isDistinct = isDistinct;
	}

	public boolean isDistinct() {
		return isDistinct;
	}

	public Node getHavingClause() {
		return havingClause;
	}

	public void setHavingClause(Node havingClause) {
		this.havingClause = havingClause;
	}

	public ArrayList<Node> getAggConstraints() {
		return aggConstraints;
	}

	public void setAggConstraints(ArrayList<Node> aggConstraints) {
		this.aggConstraints = aggConstraints;
	}

	public int getFinalCount() {
		return finalCount;
	}

	public void setFinalCount(int finalCount) {
		this.finalCount = finalCount;
	}

	public int getNoOfGroups() {
		return noOfGroups;
	}

	public void setNoOfGroups(int noOfGroups) {
		this.noOfGroups = noOfGroups;
	}

	public Set<HashSet<Node>> getUniqueElements() {
		return uniqueElements;
	}

	public void setUniqueElements(Set<HashSet<Node>> uniqueElements) {
		this.uniqueElements = uniqueElements;
	}

	public Set<Node> getSingleValuedAttributes() {
		return singleValuedAttributes;
	}

	public void setSingleValuedAttributes(Set<Node> singleValuedAttributes) {
		this.singleValuedAttributes = singleValuedAttributes;
	}

	public Set<HashSet<Node>> getUniqueElementsAdd() {
		return uniqueElementsAdd;
	}

	public void setUniqueElementsAdd(Set<HashSet<Node>> uniqueElementsAdd) {
		this.uniqueElementsAdd = uniqueElementsAdd;
	}

	public Set<Node> getSingleValuedAttributesAdd() {
		return singleValuedAttributesAdd;
	}

	public void setSingleValuedAttributesAdd(Set<Node> singleValuedAttributesAdd) {
		this.singleValuedAttributesAdd = singleValuedAttributesAdd;
	}

	public Vector<Vector<Node>> getEquivalenceClassesKilled() {
		return equivalenceClassesKilled;
	}

	public void setEquivalenceClassesKilled(Vector<Node> equivalenceClassesKilled) {
		this.equivalenceClassesKilled.add(equivalenceClassesKilled);
	}

	public ArrayList<QueryBlockDetails> getFromClauseSubQueries() {
		return fromClauseSubQueries;
	}

	public void setFromClauseSubQueries(
			ArrayList<QueryBlockDetails> fromClauseSubQueries) {
		this.fromClauseSubQueries = fromClauseSubQueries;
	}

	public ArrayList<QueryBlockDetails> getWhereClauseSubQueries() {
		return whereClauseSubQueries;
	}

	public void setWhereClauseSubQueries(
			ArrayList<QueryBlockDetails> whereClauseSubQueries) {
		this.whereClauseSubQueries = whereClauseSubQueries;
	}

	public ArrayList<String> getBaseRelations() {
		return baseRelations;
	}

	public void setBaseRelations(ArrayList<String> baseRelations) {
		this.baseRelations = baseRelations;
	}

	// parismita
	public ArrayList<String> getBaseSQRelations() {
		return baseSQRelations;
	}

	public void setBaseSQRelations(ArrayList<String> baseSQRelations) {
		this.baseSQRelations = baseSQRelations;
	}

	public void putBaseSQRelations(String baseSQRelation) {
		this.baseSQRelations.add(baseSQRelation);
	}

	public HashMap<String, Integer> getFinalCountMap() {
		return finalCountMap;
	}

	public void setFinalCountMap(HashMap<String, Integer> finalCountMap) {
		this.finalCountMap = finalCountMap;
	}

	public HashMap<Column, ArrayList<Node>> getColAggMap() {
		return colAggMap;
	}

	public void setColAggMap(HashMap<Column, ArrayList<Node>> colAggMap) {
		this.colAggMap = colAggMap;
	}

	public HashMap<String, String> getParamMap() {
		return paramMap;
	}

	public void setParamMap(HashMap<String, String> paramMap) {
		this.paramMap = paramMap;
	}

	public HashMap<ArrayList<String>, Node> getParamsNodeMap() {
		return paramsNodeMap;
	}

	public void setParamsNodeMap(HashMap<ArrayList<String>, Node> paramsNodeMap) {
		this.paramsNodeMap = paramsNodeMap;
	}

	public int getpConstraintId() {
		return pConstraintId;
	}

	public void setpConstraintId(int pConstraintId) {
		this.pConstraintId = pConstraintId;
	}

	public int getParamCount() {
		return paramCount;
	}

	public void setParamCount(int paramCount) {
		this.paramCount = paramCount;
	}

	public HashMap<String, Node> getConstraintsWithParameters() {
		return constraintsWithParameters;
	}

	public void setConstraintsWithParameters(HashMap<String, Node> constraintsWithParameters) {
		this.constraintsWithParameters = constraintsWithParameters;
	}

	/**
	 * @return the caseConditionMap
	 */
	public Map<Integer, CaseExpression> getCaseConditionMap() {
		return caseConditionMap;
	}

	/**
	 * @param caseConditionMap the caseConditionMap to set
	 */
	public void setCaseConditionMap(Map<Integer, CaseExpression> caseConditionMap) {
		this.caseConditionMap = caseConditionMap;
	}

	public static void ProcessProjectedColumnsFromFClauseSQ(GenerateCVC1 cvc, QueryBlockDetails outerBlock) {

		if (outerBlock == null)
			return;
		for (QueryBlockDetails qbt : outerBlock.getFromClauseSubQueries()) {
			ProcessProjectedColumnsFromFClauseSQ(cvc, qbt);
			ArrayList<Node> pr1 = qbt.getProjectedCols();
			ArrayList<Node> pr2 = outerBlock.getProjectedCols();
			for (Node n : pr2) {
				if (pr1.contains(n)) {
					n.fromBelowLevelFClauseSQ = true;
				}else{
					for(Node in: pr1){
						if(in.getType().equalsIgnoreCase(in.getColRefType()) && in.getColumn()==n.getColumn() && in.getTableNameNo() == n.getTableNameNo())
							n.fromBelowLevelFClauseSQ = true;
					}
				}
			}
			// ArrayList<Node>condsOfOuterBlock = outerBlock.getC
		}
	}

}
